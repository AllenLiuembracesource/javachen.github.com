---
layout: post
title: POI-2.5.jar
categories:
- OpenSource
tags:
- Excel
- Open Sources
- POI
published: true
comments: true
---
<p>POI是Apache的Jakata项目，POI 代表 Poor Obfuscation Implementation，即不良模糊化实现。POI 的目标就是提供一组 Java API 来使得基于 Microsoft OLE 2 Compound Document 格式的 Microsoft Office 文件易于操作。</p>

<p>POI的jar包现在为3.6版本的了，在网上搜索一下可以搜到2.5版本、3.01版本、3.5版本的，而且每个版本之间的差异很大。由于公司项目需要Excel的导入导出功能，而且公司项目中的POI jar包为2.5版本的，所以只能基于POI-2.5.1.jar进行开发。
<!--more-->
POI的jar包主要包括以下几个：<br />
poi-2.5.1-final-20040804.jar<br />
poi-contrib-2.5.1-final-20040804.jar<br />
poi-scratchpad-2.5.1-final-20040804.jar</p>

<p>在网上搜索了这几个包分别的作用，暂时没有查到，一般的文件操作只用第一个jar包就可以了。POI包中提供了一些HSSF对象的API。</p>

<p>HSSF 代表 Horrible Spreadsheet Format（可怕的电子表格格式）。HSSF提供给用户使用的对象在org.apache.poi.hssf.usermodel包中,主要部分包括Excell对象，样式和格式，还有辅助操作。有以下几种对象：<br />
HSSFWorkbook excell的文档对象<br />
HSSFSheet excell的表单<br />
HSSFRow excell的行<br />
HSSFCell excell的格子单元<br />
HSSFFont excell字体<br />
HSSFName 名称<br />
HSSFDataFormat 日期格式<br />
辅助操作包括<br />
HSSFDateUtil 日期<br />
HSSFPrintSetup 打印<br />
HSSFErrorConstants 错误信息表<br />
在poi1.7中才有以下3项：<br />
HSSFHeader sheet头<br />
HSSFFooter sheet尾<br />
HSSFCellStyle cell样式</p>

<p>创建一个Excel的例子：
<pre lang="java" line="1">
HSSFWorkbook workbook = new HSSFWorkbook(); // 产生工作簿对象
HSSFSheet sheet = workbook.createSheet(); // 产生工作表对象
// 设置第一个工作表的名称为firstSheet，为了工作表能支持中文，设置字符编码为UTF_16
workbook.setSheetName(0, "firstSheet", HSSFWorkbook.ENCODING_COMPRESSED_UNICODE);
// 产生一行
HSSFRow row = sheet.createRow((short) 0);
// 产生第一个单元格
HSSFCell cell = row.createCell((short) 0);
// 设置单元格内容为字符串型
cell.setCellType(HSSFCell.CELL_TYPE_BOOLEAN);
// 为了能在单元格中写入中文，设置字符编码为UTF_16。
cell.setEncoding(HSSFCell.ENCODING_UTF_16);
// 往第一个单元格中写入信息
cell.setCellValue("测试成功");
FileOutputStream fOut = new FileOutputStream(xlsFile);
workbook.write(fOut);
fOut.flush();
fOut.close();
System.out.println("文件生成...");
// 以下语句读取生成的Excel文件内容
FileInputStream fIn = new FileInputStream(xlsFile);
HSSFWorkbook readWorkBook = new HSSFWorkbook(fIn);
HSSFSheet readSheet = readWorkBook.getSheet("firstSheet");
HSSFRow readRow = readSheet.getRow(0);
HSSFCell readCell = readRow.getCell((short) 0);
System.out.println("第一个单元是：" + readCell.getStringCellValue());
</pre>
从上面的一个例子，基本上可以明白POI操作Excel的一些方法与步骤，要生成一个HSSFWorkbook工作簿对象，关键是要有一个文件输入输出流对象，而这个IO留对象可以来自文件上的一个文件也可以来自上传时候得到的一个输入流对象（导入Excel的时候，可以得到Excel的输入流，将Excel里的数据写入数据库，这样就可以完成Excel的导入并且不需要将Excel上传到服务器。用struts上传就可以使用这种方式。）。得到了一个HSSFWorkbook工作簿对象，就可以做一些读取或写入或修改样式的操作了。</p>

<p>1)excel中只要是数字就是double型的通过cellgetNumericCellValue()读取<br />
2)在excel中一份workbook中可能会有好几个表格，这些表格的顺序是从0开始的;行列也都是从下标0开始的。</p>

<p>网上关于POI的操作例子多半是关于Excel的操作，其实POI也能读写word,ppt，以下就是在网上找到的一个读写word实例：﻿
<pre lang="java" line="1">
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;</pre></p>

<p>import org.apache.poi.poifs.filesystem.DirectoryEntry;<br />
import org.apache.poi.poifs.filesystem.DocumentEntry;<br />
import org.apache.poi.poifs.filesystem.DocumentInputStream;<br />
import org.apache.poi.poifs.filesystem.POIFSFileSystem;<br />
import org.apache.poi.util.LittleEndian;</p>

<p>public class WordExtractor {<br />
	public WordExtractor() {<br />
	}</p>

<p>	public String extractText(InputStream in) throws IOException {<br />
		ArrayList text = new ArrayList();<br />
		POIFSFileSystem fsys = new POIFSFileSystem(in);</p>

<p>		DocumentEntry headerProps = (DocumentEntry) fsys.getRoot().getEntry(<br />
				"WordDocument");<br />
		DocumentInputStream din = fsys<br />
				.createDocumentInputStream("WordDocument");<br />
		byte[] header = new byte[headerProps.getSize()];</p>

<p>		din.read(header);<br />
		din.close();<br />
		// Prende le informazioni dall'header del documento<br />
		int info = LittleEndian.getShort(header, 0xa);</p>

<p>		boolean useTable1 = (info & 0x200) != 0;</p>

<p>		// boolean useTable1 = true;</p>

<p>		// Prende informazioni dalla piece table<br />
		int complexOffset = LittleEndian.getInt(header, 0x1a2);<br />
		// int complexOffset = LittleEndian.getInt(header);</p>

<p>		String tableName = null;<br />
		if (useTable1) {<br />
			tableName = "1Table";<br />
		} else {<br />
			tableName = "0Table";<br />
		}</p>

<p>		DocumentEntry table = (DocumentEntry) fsys.getRoot()<br />
				.getEntry(tableName);<br />
		byte[] tableStream = new byte[table.getSize()];</p>

<p>		din = fsys.createDocumentInputStream(tableName);</p>

<p>		din.read(tableStream);<br />
		din.close();</p>

<p>		din = null;<br />
		fsys = null;<br />
		table = null;<br />
		headerProps = null;</p>

<p>		int multiple = findText(tableStream, complexOffset, text);</p>

<p>		StringBuffer sb = new StringBuffer();<br />
		int size = text.size();<br />
		tableStream = null;</p>

<p>		for (int x = 0; x < size; x++) {</p>

<p>			WordTextPiece nextPiece = (WordTextPiece) text.get(x);<br />
			int start = nextPiece.getStart();<br />
			int length = nextPiece.getLength();</p>

<p>			boolean unicode = nextPiece.usesUnicode();<br />
			String toStr = null;<br />
			if (unicode) {<br />
				toStr = new String(header, start, length * multiple, "UTF-16LE");<br />
			} else {<br />
				toStr = new String(header, start, length, "ISO-8859-1");<br />
			}<br />
			sb.append(toStr).append(" ");</p>

<p>		}<br />
		return sb.toString();<br />
	}</p>

<p>	private static int findText(byte[] tableStream, int complexOffset,<br />
			ArrayList text) throws IOException {<br />
		// actual text<br />
		int pos = complexOffset;<br />
		int multiple = 2;<br />
		// skips through the prms before we reach the piece table. These contain<br />
		// data<br />
		// for actual fast saved files<br />
		while (tableStream[pos] == 1) {<br />
			pos++;<br />
			int skip = LittleEndian.getShort(tableStream, pos);<br />
			pos += 2 + skip;<br />
		}<br />
		if (tableStream[pos] != 2) {<br />
			throw new IOException("corrupted Word file");<br />
		} else {<br />
			// parse out the text pieces<br />
			int pieceTableSize = LittleEndian.getInt(tableStream, ++pos);<br />
			pos += 4;<br />
			int pieces = (pieceTableSize - 4) / 12;<br />
			for (int x = 0; x < pieces; x++) {<br />
				int filePos = LittleEndian.getInt(tableStream, pos<br />
						+ ((pieces + 1) * 4) + (x * 8) + 2);<br />
				boolean unicode = false;<br />
				if ((filePos & 0x40000000) == 0) {<br />
					unicode = true;<br />
				} else {<br />
					unicode = false;<br />
					multiple = 1;<br />
					filePos &= ~(0x40000000); // gives me FC in doc stream<br />
					filePos /= 2;<br />
				}<br />
				int totLength = LittleEndian.getInt(tableStream, pos + (x + 1)<br />
						* 4)<br />
						- LittleEndian.getInt(tableStream, pos + (x * 4));</p>

<p>				WordTextPiece piece = new WordTextPiece(filePos, totLength,<br />
						unicode);<br />
				text.add(piece);</p>

<p>			}</p>

<p>		}<br />
		return multiple;<br />
	}</p>

<p>	public boolean writeWordFile(String path, String content) {<br />
		boolean w = false;<br />
		try {</p>

<p>			// byte b[] = content.getBytes("ISO-8859-1");<br />
			byte b[] = content.getBytes();</p>

<p>			ByteArrayInputStream bais = new ByteArrayInputStream(b);</p>

<p>			POIFSFileSystem fs = new POIFSFileSystem();<br />
			DirectoryEntry directory = fs.getRoot();</p>

<p>			DocumentEntry de = directory.createDocument("WordDocument", bais);</p>

<p>			FileOutputStream ostream = new FileOutputStream(path);</p>

<p>			fs.writeFilesystem(ostream);</p>

<p>			bais.close();<br />
			ostream.close();</p>

<p>		} catch (IOException e) {<br />
			e.printStackTrace();<br />
		}</p>

<p>		return w;<br />
	}</p>

<p>	public static void main(String[] args) {<br />
		WordExtractor w = new WordExtractor();<br />
		POIFSFileSystem ps = new POIFSFileSystem();<br />
		try {</p>

<p>			File file = new File("C:\\test.doc");</p>

<p>			InputStream in = new FileInputStream(file);<br />
			String s = w.extractText(in);<br />
			System.out.println(s);</p>

<p>			w.writeWordFile("D:\\test.doc", "hello ");<br />
		} catch (Exception e) {<br />
			e.printStackTrace();<br />
		}</p>

<p>	}</p>

<p>}</p>

<p>class WordTextPiece {<br />
	private int _fcStart;<br />
	private boolean _usesUnicode;<br />
	private int _length;</p>

<p>	public WordTextPiece(int start, int length, boolean unicode) {<br />
		_usesUnicode = unicode;<br />
		_length = length;<br />
		_fcStart = start;<br />
	}</p>

<p>	public boolean usesUnicode() {<br />
		return _usesUnicode;<br />
	}</p>

<p>	public int getStart() {<br />
		return _fcStart;<br />
	}</p>

<p>	public int getLength() {<br />
		return _length;<br />
	}</p>

<p>}</p>

<p></p>

---
layout: post
title: JavaScript中的闭包
categories:
- JavaScript
tags:
- JavaScript
published: true
comments: true
---
<p>“官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量<br />
也是该表达式的一部分。<span style="color: #0000ff;">闭包意味着内层的函数可以引用存在于包围它的函数内的变量，即使外层函数的执行已经终止。</span>
通过自动执行匿名函数组合闭包，便可把原本属于全局的变量隐藏起来。<!--more-->
看下面的例子：<br />
&lt;script type="text/javascript"&gt;<br />
(function(){<br />
var msg = "Hello";<br />
window.onunload  = function(){<br />
alert(msg);//输出Hello<br />
}
})()</p>

<p>//alert(msg);//出现未定义<br />
&lt;/script&gt;</p>

<p>在使用setTimeout时，我们经常也用上了闭包。<br />
&lt;html&gt;<br />
&lt;head&gt;<br />
&lt;title&gt;demo&lt;/title&gt;<br />
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;<br />
&lt;script type="text/javascript"&gt;<br />
window.onload = function(){<br />
var obj = document.getElementById("abc");<br />
obj.style.border = "1px solid #000";<br />
setTimeout(function(){<br />
obj.style.color = "red";<br />
},1000)</p>

<p>function DeAlert(msg , time){<br />
setTimeout( function(){<br />
alert(msg);<br />
},time)<br />
}
DeAlert("hello",2000);<br />
}
&lt;/script&gt;<br />
&lt;/head&gt;<br />
&lt;body&gt;<br />
&lt;div id="abc"&gt;CssRain&lt;/div&gt;<br />
&lt;/body&gt;<br />
&lt;/html&gt;</p>

<p>以这种方式使用setTimeout()，可以避免一些问题。</p>

<p><span style="color: #0000ff;"><strong>关于闭包的解释：</strong></span>
看下面这段代码：</p>

<p>function a(){<br />
var i=0;<br />
function b(){<br />
alert(++i);<br />
}
return b;<br />
}
var c = a();<br />
c();</p>

<p>这段代码有两个特点：<br />
1、函数b嵌套在函数a内部；<br />
2、函数a返回函数b。</p>

<p>这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：<br />
当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。<br />
闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。</p>

<p><span style="color: #0000ff;"><strong>关于闭包内部运行机制：</strong></span>
如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：<span style="color: #0000ff;">函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)</span>。以函数a从定义到执行的过程为例阐述这几个概念。</p>

<p>1、当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则<br />
scope chain中只有window对象。<br />
2、当函数a执行的时候，a会进入相应的执行环境(excution context)。<br />
3、在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。<br />
4、然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a 的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。<br />
5、下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。<br />
6、最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。</p>

<p>到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。</p>

<p>当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象。当在函数b中访问一个变量的时候，搜索顺序是先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。<span style="color: #0000ff;">如果整个作用域链上都无法找到，则返回undefined。如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。</span>这就是Javascript中的变量查找机制。</p>

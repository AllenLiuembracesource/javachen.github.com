---
layout: post
title: Java中的集合类
categories:
- Java Core
tags:
- collection
- Java Core
- Map
- Set
published: true
comments: true
---
<p>集合类存放于java.util包中。存放的都是对象的引用，而非对象本身，出于表达上的便利，我们称集合中的对象就是指集合中对象的引用（reference)。<br />
集合类型主要有3种：set(集）、list(列表）和map(映射)。<br />
3种类型都是接口，是不能被NEW 的，要想初始化一个对象，只能NEW它的实现类。<br />
1）set集<br />
集（set）是最简单的一种集合，它的对象不按特定方式排序，只是简单地把对象加入集合中，就像往口袋里放东西。对集中成员的访问和操作是通过集中对象的引用进行的，所以集中不能有重复对象。（set）集也有多种变体，可以实现排序等功能，如TreeSet（在（set）集中实现排序功能），它把对象添加到集中的操作将变为按照某种比较规则将其插入到有序的对象序列中。它实现的是SortedSet接口，也就是加入了对象比较的方法。通过对集中的对象迭代，我们可以得到一个升序的对象集合。<br />
Set的功能方法<br />
Set(interface): 存入Set的每个元素必须是唯一的，因为Set不保存重复元素。加入Set的Object必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br />
HashSet: 为快速查找而设计的Set。存入HashSet的对象必须定义hashCode()。<br />
TreeSet: 保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。<br />
LinkedHashSet: 具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。<br />
HashSet采用散列函数对元素进行排序，这是专门为快速查询而设计的；TreeSet采用红黑树的数据结构进行排序元 素；LinkedHashSet内部使用散列以加快查询速度，同时使用链表维护元素的次序，使得看起来元素是以插入的顺序保存的。需要注意的是，生成自己 的类时，Set需要维护元素的存储顺序，因此要实现Comparable接口并定义compareTo()方法<!--more-->
2）list列表<br />
列表的主要特征是其对象以线性方式存储，没有特定顺序，只有一个开头和一个结尾，当然，它与根本没有顺序的集是不同的。<br />
列表在数据结构中分别表现为：数组和向量、链表、堆栈、队列。<br />
关于实现列表的集合类，是我们日常工作中经常用到的。<br />
List的功能方法<br />
List(interface): 次序是List最重要的特点；它确保维护元素特定的顺序。List为Collection添加了许多方法，使得能够向List中间插入与移除元素(只推荐 LinkedList使用)。一个List可以生成ListIterator，使用它可以从两个方向遍历List，也可以从List中间插入和删除元素。<br />
ArrayList: 由数组实现的List。它允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。ListIterator只应该用来由后向前遍历ArrayList，而不是用来插入和删除元素，因为这比LinkedList开销要大很多。<br />
LinkedList: 对顺序访问进行了优化，向List中间插入与删除得开销不大，随机访问则相对较慢(可用ArrayList代替)。它具有方法addFirst()、 addLast()、getFirst()、getLast()、removeFirst()、removeLast()，这些方法(没有在任何接口或基 类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。<br />
Vector类<br />
Vector非常类似ArrayList，但是Vector是同 步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个 Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。</p>

<p>Stack 类<br />
Stack继承自 Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方 法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>

<p>3）map映射<br />
映射与集或列表有明显区别，映射中每个项都是成对的。映射中存储的每个对象都有一个相关的关键字（Key）对象，关键字决定了对象在映射中的存储位置，检索对象时必须提供相应的关键字，就像在字典中查单词一样。关键字应该是唯一的。map没有继承Collection接口，Map提供key到value的映射。一个Map中 不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合， 或者一组key-value映射。<br />
Hashtable类<br />
Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。<br />
添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。<br />
Hashtable 通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的 均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。<br />
使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”：<br />
Hashtable numbers = new Hashtable();<br />
numbers.put(“one”, new Integer(1));<br />
numbers.put(“two”, new Integer(2));<br />
numbers.put(“three”, new Integer(3));<br />
要取出一个数，比如2，用相应的key：<br />
Integer n = (Integer)numbers.get(“two”);<br />
System.out.println(“two = ” + n);<br />
由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方 法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相 同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如 果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希 表的操作。<br />
如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。<br />
Hashtable是同步的。</p>

<p>HashMap类<br />
HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但 是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap的容量成比 例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。</p>

<p>WeakHashMap类<br />
WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>

<p>总结<br />
如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。<br />
如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。<br />
要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。<br />
尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</p>

<p>同步性<br />
Vector 是同步的。这个类中的一些方法保证了Vector中的对象是线程安全的。而ArrayList则是异步的，因此ArrayList中的对象并不是线程安全 的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用ArrayList是一个很好的选择，这样可以避免由于同步带来的不必要的 性能开销。<br />
数据增长<br />
从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类 型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长 度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用 Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。<br />
使用模式<br />
在ArrayList和Vector中， 从一个指定的位置（通过索引）查找数据或是在集合的末尾增加、移除一个元素所花费的时间是一样的，这个时间我们用O(1)表示。但是，如果在集合的其他位 置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在 进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行位移的操作。这一切意味着什么呢？<br />
这意味着，你只是查找特定位置的元素或只在集 合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是其他操作，你最好选择其他的集合操作类。比如，LinkList集合类 在增加或移除集合中任何位置的元素所花费的时间都是一样的?O(1)，但它在索引一个元素的使用缺比较慢－O(i),其中i是索引的位置.使用 ArrayList也很容易，因为你可以简单的使用索引来代替创建iterator对象的操作。LinkList也会为每个插入的元素创建对象，所有你要 明白它也会带来额外的开销。<br />
最后，在《Practical Java》一书中Peter Haggar建议使用一个简单的数组（Array）来代 替Vector或ArrayList。尤其是对于执行效率要求高的程序更应如此。因为使用数组(Array)避免了同步、额外的方法调用和不必要的重新分 配空间的操作。</p>

<p>Hashtable基本用法概述<br />
Hashtable-哈希表类<br />
以哈希表的形式存储数据,数据的形式是键值对.<br />
特点:<br />
查找速度快,遍历相对慢<br />
键值不能有空指针和重复数据<br />
创建<br />
Hashtable&lt;Integer,String&gt; ht=new Hashtable&lt;Integer,String&gt;();<br />
添值<br />
ht.put(1,"Andy");<br />
ht.put(2,"Bill");<br />
ht.put(3,"Cindy");<br />
ht.put(4,"Dell");<br />
ht.put(5,"Felex");<br />
ht.put(6,"Edinburg");<br />
ht.put(7,"Green");<br />
取值<br />
String str=ht.get(1);<br />
System.out.println(str);// Andy<br />
对键进行遍历<br />
Iterator it = ht.keySet().iterator();<br />
while (it.hasNext()) {<br />
Integer key = (Integer)it.next();<br />
System.out.println(key);<br />
}
对值进行遍历<br />
Iterator it = ht.values().iterator();<br />
while (it.hasNext()) {<br />
String value =(String) it.next();<br />
System.out.println(value);<br />
}
取Hashtable记录数<br />
Hashtable&lt;Integer,String&gt; ht=new Hashtable&lt;Integer,String&gt;();<br />
ht.put(1,"Andy");<br />
ht.put(2,"Bill");<br />
ht.put(3,"Cindy");<br />
ht.put(4,"Dell");<br />
ht.put(5,"Felex");<br />
ht.put(6,"Edinburg");<br />
ht.put(7,"Green");<br />
int i=ht.size();// 7<br />
删除元素<br />
Hashtable&lt;Integer,String&gt; ht=new Hashtable&lt;Integer,String&gt;();<br />
ht.put(1,"Andy");<br />
ht.put(2,"Bill");<br />
ht.put(3,"Cindy");<br />
ht.put(4,"Dell");<br />
ht.put(5,"Felex");<br />
ht.put(6,"Edinburg");<br />
ht.put(7,"Green");<br />
ht.remove(1);<br />
ht.remove(2);<br />
ht.remove(3);<br />
ht.remove(4);<br />
System.out.println(ht.size());// 3</p>

<p>Iterator it = ht.values().iterator();<br />
while (it.hasNext()) {<br />
// Get value<br />
String value =(String) it.next();<br />
System.out.println(value);<br />
}
输出:<br />
3
Green<br />
Edinburg<br />
Felex</p>

<p>java中的hashcode()和equals()方法详解<br />
1. 首先equals()和hashcode()这两个方法都是从object类中继承过来的。<br />
equals()方法在object类中定义如下：<br />
public boolean equals(Object obj) {<br />
return (this == obj);<br />
}
很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们必需清楚，当String 、Math、还有Integer、Double。。。。等这些封装类在使用equals()方法时，已经覆盖了object类的equals（）方法。比 如在String类中如下：<br />
public boolean equals(Object anObject) {<br />
if (this == anObject) {<br />
return true;<br />
}
if (anObject instanceof String) {<br />
String anotherString = (String)anObject;<br />
int n = count;<br />
if (n == anotherString.count) {<br />
char v1[] = value;<br />
char v2[] = anotherString.value;<br />
int i = offset;<br />
int j = anotherString.offset;<br />
while (n-- != 0) {<br />
if (v1[i++] != v2[j++])<br />
return false;<br />
}
return true;<br />
}
}<br />
return false;<br />
}
很明显，这是进行的内容比较，而已经不再是地址的比较。依次类推Double、Integer、Math。。。。等等这些类都是重写了equals()方法的，从而进行的是内容的比较。当然了基本类型是进行值的比较，这个没有什么好说的。<br />
我们还应该注意，Java语言对equals()的要求如下，这些要求是必须遵循的：<br />
• 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。<br />
• 反射性：x.equals(x)必须返回是“true”。<br />
• 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。<br />
• 还有一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。<br />
• 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。<br />
以上这五点是重写equals()方法时，必须遵守的准则，如果违反会出现意想不到的结果，请大家一定要遵守。<br />
2. 其次是hashcode() 方法，在object类中定义如下：<br />
public native int hashCode();<br />
说明是一个本地方法，它的实现是根据本地机器相关的。当然我们可以在自己写的类中覆盖hashcode()方法，比如String、Integer、 Double。。。。等等这些类都是覆盖了hashcode()方法的。例如在String类中定义的hashcode()方法如下：<br />
public int hashCode() {<br />
int h = hash;<br />
if (h == 0) {<br />
int off = offset;<br />
char val[] = value;<br />
int len = count;<br />
for (int i = 0; i &lt; len; i++) {<br />
h = 31*h + val[off++];<br />
}
hash = h;<br />
}
return h;<br />
}
解释一下这个程序（String的API中写到）：<br />
s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]<br />
使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂。（空字符串的哈希码为 0。）</p>

<p>3.这里我们首先要明白一个问题：<br />
equals()相等的两个对象，hashcode()一定相等；<br />
equals（）不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等。（我的理解是由于哈希码在生成的时候产生冲突造成的）。<br />
反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。解释 下第3点的使用范围，我的理解是在object、String等类中都能使用。在object类中，hashcode()方法是本地方法，返回的是对象的 地址值，而object类中的equals()方法比较的也是两个对象的地址值，如果equals()相等，说明两个对象地址值也相等，当然 hashcode()也就相等了；在String类中，equals()返回的是两个对象内容的比较，当两个对象内容相等时，<br />
Hashcode()方法根据String类的重写（第2点里面已经分析了）代码的分析，也可知道hashcode()返回结果也会相等。以此 类推，可以知道Integer、Double等封装类中经过重写的equals()和hashcode()方法也同样适合于这个原则。当然没有经过重写的 类，在继承了object类的equals()和hashcode()方法后，也会遵守这个原则。</p>

<p>4.谈到hashcode()和equals()就不能不说到hashset,hashmap,hashtable中的使用，具体是怎样呢，请看如下分析：<br />
Hashset是继承Set接口，Set接口又实现Collection接口，这是层次关系。那么hashset是根据什么原理来存取对象的呢？<br />
在hashset中不允许出现重复对象，元素的位置也是不确定的。在hashset中又是怎样判定元素是否重复的呢？这就是问题的关键所在，经过一下午的查询求证终于获得了一点启示，和大家分享一下，在java的集合中，判断两个对象是否相等的规则是：<br />
1)，判断两个对象的hashCode是否相等<br />
如果不相等，认为两个对象也不相等，完毕<br />
如果相等，转入2<br />
（这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。后面会重点讲到这个问题。）<br />
2)，判断两个对象用equals运算是否相等<br />
如果不相等，认为两个对象也不相等<br />
如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键）<br />
为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。<br />
比如下面的代码：</p>

<p>public static void main(String args[]){<br />
String s1=new String("zhaoxudong");<br />
String s2=new String("zhaoxudong");<br />
System.out.println(s1==s2);//false<br />
System.out.println(s1.equals(s2));//true<br />
System.out.println(s1.hashCode());//s1.hashcode()等于s2.hashcode()<br />
System.out.println(s2.hashCode());<br />
Set hashset=new HashSet();<br />
hashset.add(s1);<br />
hashset.add(s2);<br />
/*实质上在添加s1,s2时，运用上面说到的两点准则，可以知道hashset认为s1和s2是相等的，是在添加重复元素，所以让s2覆盖了s1;*/<br />
Iterator it=hashset.iterator();<br />
while(it.hasNext())<br />
{
System.out.println(it.next());<br />
}
最后在while循环的时候只打印出了一个”zhaoxudong”。<br />
输出结果为：false<br />
true<br />
-967303459<br />
-967303459<br />
这是因为String类已经重写了equals()方法和hashcode()方法，所以在根据上面的第1.2条原则判定时，hashset认为它们是相等的对象，进行了重复添加。<br />
但是看下面的程序：<br />
import java.util.*;<br />
public class HashSetTest {<br />
public static void main(String[] args)     {<br />
HashSet hs=new HashSet();<br />
hs.add(new Student(1,"zhangsan"));<br />
hs.add(new Student(2,"lisi"));<br />
hs.add(new Student(3,"wangwu"));<br />
hs.add(new Student(1,"zhangsan"));</p>

<p>Iterator it=hs.iterator();<br />
while(it.hasNext())      {<br />
System.out.println(it.next());<br />
}
}<br />
}
class Student    {<br />
int num;<br />
String name;<br />
Student(int num,String name)  {<br />
this.num=num;<br />
this.name=name;<br />
}
public String toString()    {<br />
return num+":"+name;<br />
}
}<br />
输出结果为：<br />
1:zhangsan<br />
1:zhangsan<br />
3:wangwu<br />
2:lisi<br />
问题出现了，为什么hashset添加了相等的元素呢，这是不是和hashset的原则违背了呢？回答是：没有<br />
因为在根据hashcode()对两次建立的new Student(1,"zhangsan")对象进行比较时，生成的是不同的哈希码值，所以hashset把他当作不同的对象对待了，当然此时的 equals()方法返回的值也不等（这个不用解释了吧）。那么为什么会生成不同的哈希码值呢？上面我们在比较s1和s2的时候不是生成了同样的哈希码 吗？原因就在于我们自己写的Student类并没有重新自己的hashcode()和equals()方法，所以在比较时，是继承的object类中的 hashcode()方法，呵呵，各位还记得object类中的hashcode()方法比较的是什么吧！！<br />
它是一个本地方法，比较的是对象的地址（引用地址），使用new方法创建对象，两次生成的当然是不同的对象了（这个大家都能理解吧。。。），造 成的结果就是两个对象的hashcode()返回的值不一样。所以根据第一个准则，hashset会把它们当作不同的对象对待，自然也用不着第二个准则进 行判定了。那么怎么解决这个问题呢？？<br />
答案是：在Student类中重新hashcode()和equals()方法。<br />
例如：<br />
class Student {<br />
int num;<br />
String name;<br />
Student(int num,String name) {<br />
this.num=num;<br />
this.name=name;<br />
}
public int hashCode() {<br />
return num*name.hashCode();<br />
}
public boolean equals(Object o) {<br />
Student s=(Student)o;<br />
return num==s.num &amp;&amp; name.equals(s.name);<br />
}
public String toString() {<br />
return num+":"+name;<br />
}
}<br />
根据重写的方法，即便两次调用了new Student(1,"zhangsan")，我们在获得对象的哈希码时，根据重写的方法hashcode()，获得的哈希码肯定是一样的（这一点应该没有疑问吧）。<br />
当然根据equals()方法我们也可判断是相同的。所以在向hashset集合中添加时把它们当作重复元素看待了。所以运行修改后的程序时，我们会发现运行结果是：<br />
1:zhangsan<br />
3:wangwu<br />
2:lisi<br />
可以看到重复元素的问题已经消除。<br />
关于在hibernate的pojo类中，重新equals()和hashcode()的问题：<br />
1)，重点是equals，重写hashCode只是技术要求（为了提高效率）<br />
2)，为什么要重写equals呢，因为在java的集合框架中，是通过equals来判断两个对象是否相等的<br />
3)，在hibernate中，经常使用set集合来保存相关对象，而set集合是不允许重复的。我们再来谈谈前面提到在向hashset集合中添加元素时,怎样判断对象是否相同的准则，前面说了两条，其实只要重写equals()这一条也可以。<br />
但当hashset中元素比较多时，或者是重写的equals()方法比较复杂时，我们只用equals()方法进行比较判断，效率也会非常低， 所以引入了hashcode()这个方法，只是为了提高效率，但是我觉得这是非常有必要的（所以我们在前面以两条准则来进行hashset的元素是否重复 的判断）。<br />
比如可以这样写：<br />
public int hashCode(){<br />
return  1;}//等价于hashcode无效<br />
这样做的效果就是在比较哈希码的时候不能进行判断，因为每个对象返回的哈希码都是1，每次都必须要经过比较equals()方法后才能进行判断是否重复，这当然会引起效率的大大降低。<br />
我有一个问题，如果像前面提到的在hashset中判断元素是否重复的必要方法是equals()方法（根据网上找到的观点），但是这里并没有涉及到关于哈希表的问题，可是这个集合却叫hashset，这是为什么？？<br />
我想，在hashmap,hashtable中的存储操作，依然遵守上面的准则。<br />
散列表的概念</p>

<p>1、散列表<br />
设所有可能出现的关键字集合记为U(简称全集)。实际发生(即实际存储)的关键字集合记为K（|K|比|U|小得多）。<br />
散列方法是使用函数h将U映射到表T[0..m-1]的下标上（m=O(|U|)）。这样以U中关键字为自变量，以h为函数的运算结果就是相应结点的存储地址。从而达到在O(1)时间内就可完成查找。<br />
其中：<br />
① h：U→{0，1，2，…，m-1} ，通常称h为散列函数(Hash Function)。散列函数h的作用是压缩待处理的下标范围，使待处理的|U|个值减少到m个值，从而降低空间开销。<br />
② T为散列表(Hash Table)。<br />
③ h(Ki)(Ki∈U)是关键字为Ki结点存储地址(亦称散列值或散列地址)。<br />
④ 将结点按其关键字的散列地址存储到散列表中的过程称为散列(Hashing)</p>

<p>3、散列表的冲突现象<br />
（1）冲突<br />
两个不同的关键字，由于散列函数值相同，因而被映射到同一表位置上。该现象称为冲突(Collision)或碰撞。发生冲突的两个关键字称为该散列函数的同义词(Synonym)。<br />
【例】上图中的k2≠k5，但h(k2)=h(k5)，故k2和K5所在的结点的存储地址相同。</p>

<p>（2）安全避免冲突的条件<br />
最理想的解决冲突的方法是安全避免冲突。要做到这一点必须满足两个条件：<br />
①其一是|U|≤m<br />
②其二是选择合适的散列函数。<br />
这只适用于|U|较小，且关键字均事先已知的情况，此时经过精心设计散列函数h有可能完全避免冲突。</p>

<p>（3）冲突不可能完全避免<br />
通常情况下，h是一个压缩映像。虽然|K|≤m，但|U|&gt;m，故无论怎样设计h，也不可能完全避免冲突。因此，只能在设计h时尽可能使冲突最少。同时还需要确定解决冲突的方法，使发生冲突的同义词能够存储到表中。</p>

<p>（4）影响冲突的因素<br />
冲突的频繁程度除了与h相关外，还与表的填满程度相关。<br />
设m和n分别表示表长和表中填人的结点数，则将α=n/m定义为散列表的装填因子(Load Factor)。α越大，表越满，冲突的机会也越大。通常取α≤1。</p>

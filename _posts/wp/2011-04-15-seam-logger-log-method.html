---
layout: post
title: Seam中的log日志记录方法
categories:
- Seam
tags:
- log
- Log4j
- logging
- Seam
published: true
comments: true
---
<p><strong>org.jboss.seam.log.Log</strong> 日志接口，定义一些记录的日志方法以及判断日志级别是否有效的方法
<strong>org.jboss.seam.log.LogImpl Log</strong>接口的实现类，是对log4j或是jdk日志的一个封装，其用意在于在记录的时候seam对其拦截，加入seam的一些操作。
<strong>org.jboss.seam.log.Logging </strong>获得log的工厂类，该类为首先查找log4j是否可用，如果没有配置log4j则使用jdk的日志类。
<strong>org.jboss.seam.log.LogProvider</strong> 接口，log提供者
<strong>org.jboss.seam.log.JDKProvider</strong> JDK的log提供者
<strong>org.jboss.seam.log.Log4JProvider</strong> Log4J的log提供者
<h3><span style="color: #0000ff;"><strong>如何使用seam的log记录日志呢？</strong></span></h3>
使用方法如下：
<pre lang="java" line="1">private static final LogProvider log = Logging.getLogProvider(XXXXX.class);</pre>
<!--more-->通过Logging.getLogProvider方法获得LogProvider对象，这是一个只有一个参数的方法，你还可以调用下面的方法：
<pre escaped="true" lang="java" line="1"> Logging.getLogProvider(String category, boolean wrapped)</pre>
seam对JDKProvider或Log4JProvider 做了什么样的封装呢？<br />
看看下面的代码，该方法来自Logging类：
<pre escaped="true" lang="java" line="1"> public static LogProvider getLogProvider(String category, boolean wrapped){
    return isLog4JAvailable ? new Log4JProvider(category, wrapped) 
             : new JDKProvider(category, wrapped);
 }</pre>
现在就Log4JProvider类来看看其中的实现方式
<pre lang="java" line="1">final class Log4JProvider  implements LogProvider
{
  private final Logger logger;
  private final boolean isWrapped;
  private static final String LOG_IMPL_FQCN = LogImpl.class.getName();
  private static final String LOG_PROVIDER_FQCN = Log4JProvider.class.getName();
  private static final Level TRACE;</pre></p>

<p>  Log4JProvider(String category, boolean wrapped)<br />
  {<br />
    this.logger = Logger.getLogger(category);<br />
    this.isWrapped = wrapped;<br />
  }</p>

<p>  private String getFQCN()<br />
  {<br />
    return this.isWrapped ? LOG_IMPL_FQCN : LOG_PROVIDER_FQCN;<br />
  }</p>

<p>  public void debug(Object object)<br />
  {<br />
    this.logger.log(getFQCN(), Level.DEBUG, object, null);<br />
  }<br />
  。。。。<br />
}
从什么可以看出，如果wrapped为true，则在记录日志的时候如debug的时候，this.logger.log方法的第一个参数将会是LogImpl.class.getName()，否则会是Log4JProvider.class.getName()，视乎isWrapped的作用仅仅在于此处。</p>

<p><span style="color: #ff0000;">注意到在getLogProvider(category)方法里默认调用的是getLogProvider(category，false)的方法。</span></p>

<p>Logging类中还有两个方法：
<pre lang="java" line="1">public static Log getLog(String category)
  {
    return new LogImpl(category);
  }</pre></p>

<p>  public static Log getLog(Class clazz)<br />
  {<br />
    return new LogImpl(clazz.getName());<br />
  }
通过调用上面的两个方法可以获得seam内部的log接口的一个实现，也就是获得LogImpl对象。
<pre lang="java" line="1">class LogImpl  implements Log, Externalizable
{
  private static final long serialVersionUID = -1664298172030714342L;
  private transient LogProvider log;
  private String category;</pre></p>

<p>  public LogImpl()<br />
  {<br />
  }</p>

<p>  LogImpl(String category)<br />
  {<br />
    this.category = category;<br />
    this.log = Logging.getLogProvider(category, true);<br />
  }</p>

<p>  public void debug(Object object, Object[] params) {<br />
    if (isDebugEnabled())<br />
    {<br />
      this.log.debug(interpolate(object, params));<br />
    }<br />
  }</p>

<p>  private Object interpolate(Object object, Object[] params)<br />
  {<br />
    if ((object instanceof String))<br />
    {<br />
      return Interpolator.instance().interpolate((String)object, params);<br />
    }</p>

<p>    return object;<br />
  }<br />
}
LogImpl内部实际上还是通过Logging.getLogProvider获得<span style="color: #0000ff;">LogProvider(category, true)</span>，并且第二个参数为true 。<br />
LogImpl在debug的时候，日志的内容经过<span style="color: #ff0000;">interpolate</span>方法处理之后才记录到日志。<br />
interpolate方法视乎是一个拦截方法，seam对日志的内容作了什么处理呢？这需要看Interpolator内部实现了。</p>

---
layout: post
title: Kettle运行作业之前的初始化过程
categories:
- Pentaho
tags:
- Kettle
- Pentaho
published: true
comments: true
---
<p>本文主要描述Kettle是如何通过GUI调用代码启动线程执行作业的。</p>

<p>之前用英文写了一篇文章《<a href="http://blog.javachen.com/2012/02/the-execution-process-of-kettles-job/" target="_blank">The execution process of kettle’s job</a>》 ，这篇文章只是用于英语写技术博客的一个尝试。由于很久没有使用英语写作了，故那篇文章只是简单的通过UML的序列图描述kettle运行job的一个java类调用过程。将上篇文章的序列图和这篇文章联系起来，会更加容易理解本文。</p>

<p>在Spoon界面点击运行按钮，Spoon GUI会调用Spoon.runFile()方法，这可以从xul文件（ui/menubar.xul）中的描述看出来。关于kettle中的xul的使用，不是本文重点故不在此说明。</p>

<p><pre lang="java">
public void runFile() {
	executeFile(true, false, false, false, false, null, false);
}</pre></p>

<p>public void executeFile(boolean local, boolean remote, boolean cluster,<br />
		boolean preview, boolean debug, Date replayDate, boolean safe) {<br />
	TransMeta transMeta = getActiveTransformation();<br />
	if (transMeta != null)<br />
		executeTransformation(transMeta, local, remote, cluster, preview,<br />
				debug, replayDate, safe);</p>

<p>	JobMeta jobMeta = getActiveJob();<br />
	if (jobMeta != null)<br />
		executeJob(jobMeta, local, remote, replayDate, safe, null, 0);<br />
}</p>

<p>public void executeJob(JobMeta jobMeta, boolean local, boolean remote,<br />
		Date replayDate, boolean safe, String startCopyName, int startCopyNr) {<br />
	try {<br />
		delegates.jobs.executeJob(jobMeta, local, remote, replayDate, safe,<br />
				startCopyName, startCopyNr);<br />
	} catch (Exception e) {<br />
		new ErrorDialog(shell, "Execute job",<br />
				"There was an error during job execution", e);<br />
	}<br />
}
</p>

<p>runFile()方法内部调用executeFile()方法，executeFile方法有以下几个参数：<br />
local：是否本地运行<br />
remote：是否远程运行<br />
cluster：是否集群环境运行<br />
preview：是否预览<br />
debug：是否调试<br />
replayDate：回放时间<br />
safe：是否安全模式</p>

<p>executeFile方法会先获取当前激活的转换，如果获取结果不为空，则执行该转换；否则获取当前激活的作业，执行该作业。 本文主要讨论作业的执行过程，关于转换的执行过程，之后单独一篇文章进行讨论。</p>

<p>executeJob委托SpoonJobDelegate执行其内部的executeJob方法，注意，其将JobMeta传递给了executeJob方法。SpoonJobDelegate还保存着对Spoon的引用。</p>

<p>SpoonJobDelegate的executeJob方法主要完成以下操作：<br />
1.设置Spoon的执行配置JobExecutionConfiguration类，该类设置变量、仓库、是否执行安全模式、日志等级等等。<br />
2.获得当前Job对应的图形类JobGraph。<br />
3.将执行配置类JobExecutionConfiguration的变量、参数、命令行参数设置给jobMeta。<br />
4.如果本地执行，则调用jobGraph.startJob(executionConfiguration)，如果远程执行，则委托给SpoonSlaveDelegate执行。</p>

<p>JobExecutionConfiguration类是保存job执行过程中的一些配置，该类会在Spoon、JobGraph类之间传递。</p>

<p>本文只讨论本地执行的情况，故往下查看jobGraph.startJob(executionConfiguration)方法。该方法被synchronized关键字修饰。</p>

<p>JobGraph类包含当前Spoon类的引用、以及对Job的引用。初始情况，Job的引用应该为null。该类会做以下操作：<br />
1.如果job为空或者没有运行或者没有激活，则先保存，然后往下执行作业。<br />
2.在仓库不为空的时候，通过仓库加载Job获得一个运行时的JobMeta对象，名称为runJobMeta；否则，通过文件名称直接new一个JobMeta对象，名称也为runJobMeta。<br />
3.通过仓库和runJobMeta对象构建一个Job对象，并将jobMeta对象（此对象通过JobGraph构造方法传入）的变量、参数共享给Job对象。<br />
4.Job对象添加JobEntry监听器、Job监听器。<br />
5.调用Job的start方法，启动线程开始执行一个job。</p>

<p>Job继承自Thread类，该类的run方法内部会递归执行该作业内部的作业项，限于篇幅，本文不做深究。</p>

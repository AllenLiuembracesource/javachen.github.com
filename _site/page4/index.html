
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="pragma" content="no-cache" />
    <title>JavaChen Blog</title>
    <meta name="author" content="JavaChen">
    <meta name="copyright" content="© http://blog.javachen.com" />
    <meta property="wb:webmaster" content="61eb31a6e636506d" />
    <meta name="ujianVerification" content="f8b60286538bf86567069598d8a5d6cc" />
    <meta name="wumiiVerification" content="eec4ca3c-ccdb-4c0f-9fe3-4499d87649a3" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap-responsive.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/favicon.ico">
	<!-- Update these with your own images
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
	-->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Handlee">
  </head>

  <body data-spy="scroll" data-target=".subnav" data-offset="100">

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">JavaChen Blog</a>
          <div class="nav-collapse">
            <ul class="nav">


              <li><a href="/categories.html">Categories</a></li>
              <li><a href="/about.html">About me</a></li>
              <li><a href="/archive.html">Archive</a></li>
              <li><a href="/tags.html">Tags</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        


<div class="row">
  <div class="span12">
    

<div class="row">
  <div class="span8">
  
  
  <section id="cassandra20120409getting-started-using-the-cassandra-cli">
    <article>
      <header>
      <h3><a href="/cassandra/2012/04/09/getting-started-using-the-cassandra-cli">Getting Started Using the Cassandra CLI</a></h3>
      <div class="c9">
     		Author: JavaChen
     		&emsp;&emsp;
		Categories：
			
			<a href="/categories.html#cassandra">cassandra</a>
			
			
		&emsp;&emsp;
		Tags：
			
			<a href="/tags.html#cassandra-ref">cassandra</a>
			
			,
			
			
			<a href="/tags.html#cli-ref">cli</a>
			
			
		&emsp;&emsp;
		<a href='/cassandra/2012/04/09/getting-started-using-the-cassandra-cli#comment' title='分享文章、查看评论' style="float:right;margin-right:.5em;">Comments</a>
	</div>
    </header>
    <div class="content"><p>这仅仅是一个Cassandra CLI使用方法的清单。<br />
Cassandra CLI 客户端用于处理集群中基本的数据定义（DDL）和数据维护（DML）。其处于<code>/usr/bin/cassandra-cli</code>，如果是试用包安装，或者是<code>$CASSANDRA_HOME/bin/cassandra-cli</code>，如果使用二进制文件安装。</p>

<p><h1>Starting the CLI</h1>
使用<code>cassandra-cli</code> <code>-host</code> <code>-port</code> 命令启动 Cassandra CLI，他将会连接<code>cassandra.yaml</code>文件中定义的集群名称，默认为“<em>Test Cluster</em>”。<br />
如果你有一个但节点的集群，则使用以下命令：
<pre> 
$ cassandra-cli -host localhost -port 9160
</pre>
如果想连接多节点集群中的一个节点，可以使用以下命令:
<pre>
$ cassandra-cli -host 110.123.4.5 -port 9160
</pre>
或者，可以直接执行以下命令：
<pre>
$ cassandra-cli
</pre>
登录成功之后，可以看到：
<pre>
Welcome to cassandra CLI.
Type 'help;' or '?' for help. Type 'quit;' or 'exit;' to quit.
</pre>
你必须指定连接一个节点：
<pre>
[default@unknown]connect localhost/9160;
</pre>
<!--more-->
<h1>Creating a Keyspace</h1>
<pre>
[default@unknown] CREATE KEYSPACE demo;
</pre>
下面的一个例子，创建一个叫demo的Keyspace,并且复制因子为1，使用<code>SimpleStrategy</code>复制替换策略。
<pre>
[default@unknown] CREATE KEYSPACE demo with 
        placement_strategy ='org.apache.cassandra.locator.SimpleStrategy' 
        and strategy_options = [{replication_factor:1}];
</pre>
你可以使用<code>SHOW KEYSPACES</code>来查看所有系统的和你创建的Keyspace</p>

<p><h1>Use a keyspace</h1>
<pre>
[default@unknown] USE demo;
</pre></p>

<p><h1>Creating a Column Family</h1>
<pre>
[default@demo] CREATE COLUMN FAMILY users
WITH comparator = UTF8Type
AND key_validation_class=UTF8Type
AND column_metadata = [
{column_name: full_name, validation_class: UTF8Type}
{column_name: email, validation_class: UTF8Type}
{column_name: state, validation_class: UTF8Type}
{column_name: gender, validation_class: UTF8Type}
{column_name: birth_year, validation_class: LongType}
];
</pre>
我们使用demo keyspace创建了一个column family，其名称为users，并包括5个静态列：full_name，email,state,gender,birth_year.comparator, key_validation_class和validation_class，用于设置；列名称，行key的值，列值的编码。comparator还定义了列名称的排序方式。<br />
下面命令创建一个名称为 blog_entry的动态column family，我们不需要定义列，而由应用程序稍后定义。
<pre>
[default@demo] CREATE COLUMN FAMILY blog_entry WITH comparator = TimeUUIDType AND key_validation_class=UTF8Type AND default_validation_class = UTF8Type;
</pre></p>

<p><h1>Creating a Counter Column Family</h1>
<pre>
[default@demo] CREATE COLUMN FAMILY page_view_counts WITH 
          default_validation_class=CounterColumnType 
          AND key_validation_class=UTF8Type AND comparator=UTF8Type;
</pre>
插入一行和计数列：
<pre>
[default@demo] INCR page_view_counts['www.datastax.com'][home] BY 0;
</pre>
增加计数：
<pre>
[default@demo] INCR page_view_counts['www.datastax.com'][home] BY 1;
</pre></p>

<p><h1>Inserting Rows and Columns</h1>
以下命令以一个特点的行key值插入列到users中
<pre>
[default@demo] SET users['bobbyjo']['full_name']='Robert Jones';
[default@demo] SET users['bobbyjo']['email']='bobjones@gmail.com';
[default@demo] SET users['bobbyjo']['state']='TX';
[default@demo] SET users['bobbyjo']['gender']='M';
[default@demo] SET users['bobbyjo']['birth_year']='1975';
</pre>
更新数据： set users['bobbyjo']['full_name'] = 'Jack';<br />
获取数据： get users['bobbyjo'];<br />
get命令用法参考：<a href="http://wiki.apache.org/cassandra/API#get_slice" target="_blank">API#get_slice</a>
查询数据： get users where gender= 'M';<br />
下面命令在 blog_entry中创建了一行，其行key为“yomama”，并指定了一列：timeuuid()的值为 'I love my new shoes!'
<pre>
[default@demo] SET blog_entry['yomama'][timeuuid()] = 'I love my new shoes!';
</pre></p>

<p><h1>Reading Rows and Columns</h1>
使用List命令查询记录，默认查询100条记录
<pre>
[default@demo] LIST users;
</pre>
Cassandra 默认以16进制数组的格式存储数据 为了返回可读的数据格式，可以指定编码：
<li>ascii</li>
<li>bytes</li>
<li>integer (a generic variable-length integer type)</li>
<li>lexicalUUID</li>
<li>long</li>
<li>utf8</li>
例如：
<pre>
[default@demo] GET users[utf8('bobby')][utf8('full_name')];
</pre>
你也可以使用<code>ASSUME</code>命令指定编码，例如，指定行key，行名称，行值显示ascii码格式：
<pre>
[default@demo] ASSUME users KEYS AS ascii;
[default@demo] ASSUME users COMPARATOR AS ascii;
[default@demo] ASSUME users VALIDATOR AS ascii;
</pre></p>

<p><h1>Setting an Expiring Column</h1>
例如，假设我们正在跟踪我们的用户，到期后10天的优惠券代码。我们可以定义coupon_code的列和设置该列的过期日期。例如：
<pre>
[default@demo] SET users['bobbyjo'] [utf8('coupon_code')] = utf8('SAVE20') WITH ttl=864000;
</pre>
自该列被设置值之后，经过10天或864,000秒后，其值将被标记为删除，不再由读操作返回。然而，请注意，直到Cassandra的处理过程完成，该值才会从硬盘中删除。</p>

<p><h1>Indexing a Column</h1>
给birth_year添加一个二级索引：
<pre>
[default@demo] UPDATE COLUMN FAMILY users 
            WITH comparator = UTF8Type AND column_metadata = 
            [{column_name: birth_year, validation_class: LongType, index_type: KEYS}];
</pre>
由于该列被索引了，所以可以直接通过该列查询：
<pre>
[default@demo] GET users WHERE birth_date = 1969;
</pre></p>

<p><h1>Deleting Rows and Columns</h1>
删除yomama索引的coupon_code列：
<pre>
[default@demo] DEL users ['yomama']['coupon_code'];
[default@demo] GET users ['yomama'];
</pre>
或者删除整行：
<pre>
[default@demo] DEL users ['yomama'];
</pre></p>

<p><h1>Dropping Column Families and Keyspaces</h1>
<pre>
[default@demo] DROP COLUMN FAMILY users;
[default@demo] DROP KEYSPACE demo;
</pre></p>

<p><h1>For help</h1>
<pre>
[default@unknown]help;
</pre>
查看某一个命令的详细说明：
<pre>
[default@unknown] help SET;
</pre></p>

<p><h1>To Quit</h1>
<pre>
[default@unknown]quit;
</pre></p>

<p><h1>To Execute Script</h1>
<pre>
bin/cassandra-cli -host localhost -port 9160 -f script.txt
</pre></p>

<h1>参考文章</h1>

<ul>
<li><a href="http://www.datastax.com/docs/0.8/dml/using_cli" target="_blank">Getting Started Using the Cassandra CLI</a></li>
<li><a href="http://wiki.apache.org/cassandra/CassandraCli" target="_blank">CassandraCli</a></p></li>
</ul>
</div>
    </article>
  </section>
  
  
  <section id="cassandra20120406install_singlenode-with-datastax-community-editio">
    <article>
      <header>
      <h3><a href="/cassandra/2012/04/06/install_singlenode-with-datastax-community-editio">使用DataStax Community Edition安装Cassandra单节点</a></h3>
      <div class="c9">
     		Author: JavaChen
     		&emsp;&emsp;
		Categories：
			
			<a href="/categories.html#cassandra">cassandra</a>
			
			
		&emsp;&emsp;
		Tags：
			
			<a href="/tags.html#cassandra-ref">cassandra</a>
			
			,
			
			
			<a href="/tags.html#dataStax-ref">dataStax</a>
			
			
		&emsp;&emsp;
		<a href='/cassandra/2012/04/06/install_singlenode-with-datastax-community-editio#comment' title='分享文章、查看评论' style="float:right;margin-right:.5em;">Comments</a>
	</div>
    </header>
    <div class="content"><p>本文主要记录使用DataStax Community Edition安装Cassandra单节点的过程.配置单节点的Cassandra,是为了方便快速的了解学习Cassandra.</p>

<h1>检查java环境</h1>

<p>Cassandra由java编写,需要运行中jvm虚拟机之上.如果用于生产环境,则需要jre 1.6.0-19或更高版本.
<h3>1.检查是否安装java:</h3>
<pre></p>

<h1>java -version</h1>

<p></pre>
如果你没有安装java,可以参考网上相关文章.这里主要记录在RHEL系统上安装jdk的方法.
<h3>2.安装jdk</h3>
下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">Oracle JRE</a>
1）修改执行权限:
<pre>
$ cd /tmp
$ chmod a+x jre-6u25-linux-x64-rpm.bin
</pre>
&lt;!--more--&gt;
2）解压执行RPM文件,例如:
<pre>
$ sudo ./jre-6u25-linux-x64-rpm.bin
</pre>
这样JRE会安装在/usr/java/
3）配置Oracle JRE取代OpenJDK JRE
可以使用alternatives命令添加一个链接到Oracle JRE.
<pre>
$ sudo alternatives --install /usr/bin/java java /usr/java/jre1.6.0<em>25/bin/java 20000
</pre>
4）确认是否安装JRE
<pre>
$ java -version
  java version &quot;1.6.0</em>25&quot;
  Java(TM) SE Runtime Environment (build 1.6.0_25-b06)
  Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode)
</pre>
如果OpenJDK JRE仍然被使用,可以使用alternatives命令切换到Oracle JRE.例如:
<pre>
$ sudo alternatives --config java
There are 2 programs which provide &#39;java&#39;.</p>

<h2>Selection      Command</h2>

<p>1           /usr/lib/jvm/jre-1.6.0-openjdk.x86<em>64/bin/java
*+ 2           /usr/java/jre1.6.0</em>25/bin/java
</pre></p>

<h1>在Linux系统上安装DataStax Community二进制文件</h1>

<h3>1.在用户目录创建一个目录,如datas</h3>

<pre>
$ cd $HOME
$ mkdir datas
$ cd datas
</pre>

<h3>2.下载cassandra(必须的)和OpsCenter包(可选的)</h3>

<pre>
$ wget http://downloads.datastax.com/community/dsc.tar.gz
$ wget http://downloads.datastax.com/community/opscenter.tar.gz
$ wget http://downloads.datastax.com/community/dsc-1.0.1-demo-bin.tar.gz
</pre>

<h3>3.解压</h3>

<pre>
$ tar -xzvf dsc.tar.gz
$ tar -xzvf opscenter.tar.gz
$ tar -xzvf dsc-1.0.1-demo-bin.tar.gz
$ rm *.tar.gz
</pre>

<h3>4.设置环境变量</h3>

<p>1)编辑 .bashrc 
<pre>
 vi $HOME/.bashrc
</pre>
2)添加以下代码
<pre>
export CASSANDRA<em>HOME=$HOME/datas/dsc</em>package<em>name
export DSCDEMO</em>HOME=$HOME/datas/dsc-1.0.1/demos/portfolio<em>manager
export OPSC</em>HOME=$HOME/datas/opscenter<em>package</em>name
export PATH=&quot;$PATH:$CASSANDRA<em>HOME/bin:$DSCDEMO</em>HOME/bin:$OPSC_HOME/bin&quot;
</pre></p>

<p>注意替换<font color="red">dsc<em>package</em>name</font>和<font color="red">opscenter<em>package</em>name</font>
3)保存退出
4)使该文件生效
<pre>
source $HOME/.bashrc
</pre>
<h3>5.创建保存Cassandra数据的文件和日志目录</h3>
<pre>
$ mkdir $HOME/datas/cassandra-data
</pre></p>

<h1>配置并启动单节点</h1>

<h3>1.编辑配置环境</h3>

<p>修改$CASSANDRA<em>HOME/conf/cassandra.yaml
<pre>
$ sed -i -e &quot;s,initial</em>token:,initial<em>token: 0,&quot; \
  $CASSANDRA</em>HOME/conf/cassandra.yaml</p>

<p>$ sed -i -e &quot;s,- /var/lib/cassandra/data,- $HOME/datastax/cassandra-data,&quot; \
  $CASSANDRA_HOME/conf/cassandra.yaml</p>

<p>$ sed -i -e &quot;s,saved<em>caches</em>directory: /var/lib/cassandra/saved<em>caches, \
  saved</em>caches<em>directory: $HOME/datastax/cassandra-data/saved</em>caches,&quot; \
  $CASSANDRA_HOME/conf/cassandra.yaml</p>

<p>$ sed -i -e &quot;s,commitlog<em>directory: /var/lib/cassandra/commitlog,commitlog</em>directory: \
  $HOME/datastax/cassandra-data/commitlog,&quot; $CASSANDRA_HOME/conf/cassandra.yaml
</pre></p>

<h3>2.设置日志文件位置</h3> 

<p>修改：$CASSANDRA<em>HOME/conf/log4j-server.properties
<pre>
$ sed -i -e &quot;s,log4j.appender.R.File=/var/log/cassandra/system.log, \
  log4j.appender.R.File=$HOME/datastax/cassandra-data/system.log,&quot; \
  $CASSANDRA</em>HOME/conf/log4j-server.properties
</pre>
<h3>3.配置DataStax示例程序指向Cassandra的安装位置</h3>
<pre>
$ sed -i -e &quot;s,/usr/share/cassandra,$HOME/datastax/<dsc_package_name>,&quot; \
  $DSCDEMO<em>HOME/bin/pricer
&lt;/dsc</em>package_name&gt;
</pre></p>

<h3>4.后台启动Cassandra</h3>

<pre>
$ cassandra
</pre>

<h3>5.检查cassandra环是否在运行</h3>

<pre>
$ nodetool ring -h localhost
</pre>

<h3>6.运行Portfolio Demo示例程序</h3>

<p>1)进入Portfolio目录
<pre>
$ cd $DSCDEMO<em>HOME
</pre>
2)运行 ./bin/pricer工具生成数据
<pre>
./bin/pricer --help
</pre>
下面代码生成100天的历史数据
<pre>
./bin/pricer -o INSERT</em>PRICES
./bin/pricer -o UPDATE<em>PORTFOLIOS
./bin/pricer -o INSERT</em>HISTORICAL<em>PRICES -n 100
</pre>
3)启动服务(必须在$DSCDEMO</em>HOME/website目录下启动)
<pre>
$ cd $DSCDEMO_HOME/website
$ java -jar start.jar &amp;
</pre>
4)浏览程序 http://localhost:8983/portfolio</p>

<h1>参考文章</h1>

<ul>
<li>1.<a href="http://www.datastax.com/docs/1.0/getting_started/install_singlenode" target="_blank">Installing a Single-Node Instance of Cassandra</a></li>
</ul>
</div>
    </article>
  </section>
  
  
  <section id="java20120326hash-and-hash-functions">
    <article>
      <header>
      <h3><a href="/java/2012/03/26/hash-and-hash-functions">哈希表</a></h3>
      <div class="c9">
     		Author: JavaChen
     		&emsp;&emsp;
		Categories：
			
			<a href="/categories.html#java">java</a>
			
			
		&emsp;&emsp;
		Tags：
			
			<a href="/tags.html#java-ref">java</a>
			
			,
			
			
			<a href="/tags.html#hash-ref">hash</a>
			
			,
			
			
			<a href="/tags.html#hashmap-ref">hashmap</a>
			
			
		&emsp;&emsp;
		<a href='/java/2012/03/26/hash-and-hash-functions#comment' title='分享文章、查看评论' style="float:right;margin-right:.5em;">Comments</a>
	</div>
    </header>
    <div class="content"><p><strong>定义 </strong>
一般的线性表、树，数据在结构中的相对位置是<code>随机</code>的，即和记录的关键字之间不存在确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较“的基础上，查找的效率依赖于查找过程中所进行的比较次数。 若想能直接找到需要的记录，必须在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应，这就是哈希表。</p>

<p><code>哈希表</code>又称散列表。
<em>哈希表存储的基本思想是</em>：以数据表中的每个记录的关键字 k为自变量，通过一种函数H(k)计算出函数值。把这个值解释为一块连续存储空间（即<code>数组空间</code>）的单元地址（即<code>下标</code>），将该记录存储到这个单元中。在此称该函数H为哈希函数或散列函数。按这种方法建立的表称为<code>哈希表</code>或<code>散列表</code>。<br />
哈希表是一种数据结构，它可以提供快速的插入操作和查找操作。<br />
哈希表是基于<code>数组结构</code>实现的，所以它也存在一些<em>缺点</em>： 数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重。 这个问题是哈希表不可避免的，即<code>冲突现象</code>：对不同的关键字可能得到同一哈希地址。 所以在以下情况下可以优先考虑使用哈希表： <em>不需要有序遍历数据，并且可以提前预测数据量的大小</em>。</p>

<p><strong>冲突</strong>
理想情况下，哈希函数在关键字和地址之间建立了一个一一对应关系，从而使得查找只需一次计算即可完成。由于关键字值的某种随机性，使得这种一一对应关系难以发现或构造。因而可能会出现不同的关键字对应一个存储地址。即k1≠k2，但H(k1)=H(k2)，这种现象称为冲突。<br />
把这种具有不同关键字值而具有相同哈希地址的对象称<code>同义词</code>。 在大多数情况下，冲突是不能完全避免的。这是因为所有可能的关键字的集合可能比较大，而对应的地址数则可能比较少。<br />
对于哈希技术，主要研究两个问题：<br />
（1）如何设计哈希函数以使冲突尽可能少地发生。<br />
（2）发生冲突后如何解决。</p>

<p><strong>哈希函数的构造方法</strong>
构造好的哈希函数的方法，应能使冲突尽可能地少，因而应具有较好的随机性。这样可使一组关键字的散列地址均匀地分布在整个地址空间。根据关键字的结构和分布的不同，可构造出许多不同的哈希函数。
<strong>1．直接定址法</strong>
<code>直接定址法</code>是以关键字k本身或关键字加上某个数值常量c作为哈希地址的方法。<br />
该哈希函数H(k)为：<br />
H(k)=k+c (c≥0)<br />
这种哈希函数计算简单，并且不可能有冲突发生。当关键字的分布基本连续时，可使用直接定址法的哈希函数。否则，若关键字分布不连续将造成内存单元的大量浪费</p>

<p><strong>2．除留余数法</strong></p>

<p>取关键字k除以哈希表长度m所得余数作为哈希函数地址的方法。即：<br />
H(k)=k％m<br />
这是一种较简单、也是较常见的构造方法。<br />
这种方法的关键是选择好哈希表的长度m。使得数据集合中的每一个关键字通过该函数转化后映射到哈希表的任意地址上的概率相等。<br />
理论研究表明，在m取值为素数（质数）时，冲突可能性相对较少。</p>

<p><strong>3．平方取中法</strong>
取关键字平方后的中间几位作为哈希函数地址（若超出范围时，可再取模）。<br />
设有一组关键字ABC，BCD,CDE，DEF，……其对应的机内码如表所示。假定地址空间的大小为1000，编号为0-999。现按平方取中法构造哈希函数，则可取关键字机内码平方后的中间三位作为存储位置。</p>

<p><strong>4．折叠法</strong>
这种方法适合在关键字的位数较多，而地址区间较小的情况。<br />
将关键字分隔成位数相同的几部分。然后将这几部分的叠加和作为哈希地址（若超出范围，可再取模）。<br />
例如，假设关键字为某人身份证号码430104681015355，则可以用4位为一组进行叠加。即有5355+8101+1046+430=14932，舍去高位。 则有H(430104681015355)=4932 为该身份证关键字的哈希函数地址。</p>

<p><strong>5．数值分析法</strong>
若事先知道所有可能的关键字的取值时，可通过对这些关键字进行分析，发现其变化规律，构造出相应的哈希函数。<br />
例：对如下一组关键字通过分析可知：每个关键字从左到右的第l，2，3位和第6位取值较集中，不宜作哈希地址。 剩余的第4，5，7和8位取值较分散，可根据实际需要取其中的若干位作为哈希地址。</p>

<p><strong>6. 随机数法</strong>
选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)＝random(key)，其中random为随机函数。</p>

<p><strong>7. 斐波那契（Fibonacci）散列法</strong>
平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。<br />
1，对于16位整数而言，这个乘数是40503<br />
2，对于32位整数而言，这个乘数是2654435769<br />
3，对于64位整数而言，这个乘数是11400714819323198485<br />
这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，如果你还有兴趣，就到网上查找一下“斐波那契数列”等关键字，我数学水平有限，不知道怎么描述清楚为什么，另外斐波那契数列的值居然和太阳系八大行星的轨道半径的比例出奇吻合，很神奇，对么？<br />
对我们常见的32位整数而言，公式：<br />
index = (value * 2654435769) &gt;&gt; 28<br />
如果用这种斐波那契散列法的话，那我上面的图就变成这样了：</p>

<p><strong>冲突的解决方法</strong>
假设哈希表的地址范围为0～m-l，当对给定的关键字k，由哈希函数H(k)算出的哈希地址为i（0≤i≤m-1）的位置上已存有记录，这种情况就是<code>冲突现象</code>。 处理冲突就是为该关键字的记录找到另一个“空”的哈希地址。即通过一个新的哈希函数得到一个新的哈希地址。如果仍然发生冲突，则再求下一个，依次类推。直至新的哈希地址不再发生冲突为止。<br />
常用的处理冲突的方法有开放地址法、链地址法两大类
<strong>1．开放定址法</strong>
用开放定址法处理冲突就是当冲突发生时，形成一个地址序列。沿着这个序列逐个探测，直到找出一个“空”的开放地址。将发生冲突的关键字值存放到该地址中去。<br />
如 Hi=(H(k)+d（i）) % m, i=1，2，…k (k 其中H(k)为哈希函数，m为哈希表长，d为增量函数，d(i)=dl，d2…dn-l。<br />
增量序列的取法不同，可得到不同的开放地址处理冲突探测方法。</p>

<p><strong>1）线性探测法</strong>
线性探测法是从发生冲突的地址（设为d）开始，依次探查d+l，d+2，…m-1（当达到表尾m-1时，又从0开始探查）等地址，直到找到一个空闲位置来存放冲突处的关键字。<br />
若整个地址都找遍仍无空地址，则产生溢出。<br />
线性探查法的数学递推描述公式为：<br />
d0=H(k)<br />
di=(di-1+1)% m (1≤i≤m-1)</p>

<p>【例】已知哈希表地址区间为0～10，给定关键字序列（20，30，70，15，8，12，18，63，19）。哈希函数为H(k)=k％ll，采用线性探测法处理冲突，则将以上关键字依次存储到哈希表中。试构造出该哈希表，并求出等概率情况下的平均查找长度。<br />
假设数组为A, 本题中各元素的存放过程如下：<br />
H(20)=9，可直接存放到A[9]中去。<br />
H(30)=8，可直接存放到A[8]中去。<br />
H(70)=4，可直接存放到A[4]中去。<br />
H(15)=4，冲突；<br />
d0=4<br />
d1=(4+1)%11=5，将15放入到A[5]中。<br />
H(8)=8，冲突；<br />
d0=8<br />
d1=(8+1)%11=9，仍冲突；<br />
d2=(8+2)%11=10，将8放入到A[10]中。</p>

<p>在等概率情况下成功的平均查找长度为：<br />
（1*5+2+3+4+6）/9 =20/9<br />
利用线性探查法处理冲突容易造成关键字的<code>堆积</code>问题。这是因为当连续n个单元被占用后，再散列到这些单元上的关键字和直接散列到后面一个空闲单元上的关键字都要占用这个空闲单元，致使该空闲单元很容易被占用，从而发生非同义冲突。造成平均查找长度的增加。<br />
为了克服堆积现象的发生，可以用下面的方法替代线性探查法。</p>

<p><strong>（2）平方探查法</strong>
设发生冲突的地址为d，则平方探查法的探查序列为：d+12，d+22，…直到找到一个空闲位置为止。<br />
平方探查法的数学描述公式为：<br />
d0=H(k)<br />
di=(d0+i2) % m (1≤i≤m-1)<br />
在等概率情况下成功的平均查找长度为：<br />
（1*4+2*2+3+4+6）/9 =21/9<br />
平方探查法是一种较好的处理冲突的方法，可以避免出现堆积问题。它的缺点是不能探查到哈希表上的所有单元，但至少能探查到一半单元。<br />
例如，若表长m=13，假设在第3个位置发生冲突，则后面探查的位置依次为4、7、12、6、2、0，即可以探查到一半单元。<br />
若解决冲突时，探查到一半单元仍找不到一个空闲单元。则表明此哈希表太满，需重新建立哈希表。</p>

<p><strong>2．链地址法</strong>
用链地址法解决冲突的方法是：把所有关键字为同义词的记录存储在一个线性链表中，这个链表称为同义词链表。并将这些链表的表头指针放在数组中（下标从0到m-1）。这类似于图中的邻接表和树中孩子链表的结构。<br />
由于在各链表中的第一个元素的查找长度为l，第二个元素的查找长度为2，依此类推。因此，在等概率情况下成功的平均查找长度为：<br />
(1*5+2*2+3*l+4*1)／9=16／9</p>

<p>虽然链地址法要多费一些存储空间，但是彻底解决了“堆积”问题，大大提高了查找效率。</p>

<p><strong>3. 再哈希法</strong>：<br />
Hi=R Hi(key)，<br />
R Hi均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。这种方法不易产生<code>聚集</code>，但增加了计算的时间。</p>

<p><strong>4.建立一个公共溢出区</strong>
这也是处理冲突的一种方法。<br />
假设哈希函数的值域为[0，m-1]，则设向量HashTable[0…m-1]为基本表，每个分量存放一个记录，另设立向量OverTable[0．．v]为溢出表。所有关键字和基本表中关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</p>

<p><strong>哈希表的查找及性能分析</strong>
<code>哈希法</code>是利用关键字进行计算后直接求出存储地址的。当哈希函数能得到均匀的地址分布时，不需要进行任何比较就可以直接找到所要查的记录。但实际上不可能完全避免冲突，因此查找时还需要进行探测比较。<br />
在哈希表中，虽然冲突很难避免，但发生冲突的可能性却有大有小。这主要与三个因素有关。
<strong>第一:与装填因子有关</strong>
所谓装填因子是指哈希表中己存入的元素个数n与哈希表的大小m的比值，即f=n/m。<br />
当f越小时，发生冲突的可能性越小，越大（最大为1）时，发生冲突的可能性就越大。
<strong>第二:与所构造的哈希函数有关</strong>
若哈希函数选择得当，就可使哈希地址尽可能均匀地分布在哈希地址空间上，从而减少冲突的发生。否则，若哈希函数选择不当，就可能使哈希地址集中于某些区域，从而加大冲突的发生。
<strong>第三:与解决冲突的哈希冲突函数有关</strong>
哈希冲突函数选择的好坏也将减少或增加发生冲突的可能性。</p>

<p><strong>思考</strong>
<em>哈希算法的基本思想是什么？</em>
<em>哈希算法的存储效率主要取决于什么？</em>
<em>哈希算法解决冲突的方式有哪些？</em></p>

<p><strong>java 哈希表实现</strong>
java中哈希表的实现有多个，比如hashtable，hashmap，currenthashmap，也有其他公司实现的，如apache的FashHashmap,google的mapmarker,high-lib的NonBlockingHashMap,其中差别是：</p>

<p><strong>hastable</strong>:线程同步，比较慢
<strong>hashmap</strong>：线程不同步，不同步时候读写最快（但是不能保证读到最新数据），加同步修饰的时候， 读写比较慢
<strong>currenthashmap</strong>:线程同步，默认分成16块，写入的时候只锁要写入的快，读取一般不锁块，只有读到空的时候，才锁块，性能比较高，处于hashmap同步和不同步之间。
<strong>fashhashmap</strong>:apache collection 将HashMap封装，读取的时候copy一个新的，写入比较慢（尤其是存入比较多对象每写一次都要复制一个对象，超级慢），读取快
<strong>NoBlockingHashMap</strong>： high_scale_lib实现写入慢，读取较快
<strong>MiltigetHashMap</strong>，MapMaker google collection，和CurrentHashMap性能相当，功能比较全，可以设置超时，重复的可以保存成list</p>

<p><strong>参考文章</strong>
<a href="http://course.onlinesjtu.com/mod/page/view.php?id=423" target="_blank"> http://course.onlinesjtu.com/mod/page/view.php?id=423</a>
<a href="http://www.cnblogs.com/bigshuai/articles/2398116.html" target="_blank"> http://www.cnblogs.com/bigshuai/articles/2398116.html</a></p>

<p><strong>扩展阅读</strong>
Hash碰撞的拒绝式服务攻击 <a href="http://blog.jobbole.com/11454/" target="_blank">http://blog.jobbole.com/11454/</a>
Berkeley DB Hash、Btree、Queue、Recno选择<a href=" http://www.webzone8.com/article/560.html" target="_blank"> http://www.webzone8.com/article/560.html</a>
Java Hashtable <a href="http://javapapers.com/core-java/java-hashtable/#&amp;slider1=1" target="_blank">http://javapapers.com/core-java/java-hashtable/#&amp;slider1=1</a>
Java Hashtable分析 <a href="http://kantery.iteye.com/blog/441755" target="_blank">http://kantery.iteye.com/blog/441755</a></p>
</div>
    </article>
  </section>
  
  
  <section id="kettle20120323how-to-implement-cassandra-input-and-output-in-kettle4-2">
    <article>
      <header>
      <h3><a href="/kettle/2012/03/23/how-to-implement-cassandra-input-and-output-in-kettle4-2">如何在kettle4.2上面实现cassandra的输入与输出</a></h3>
      <div class="c9">
     		Author: JavaChen
     		&emsp;&emsp;
		Categories：
			
			<a href="/categories.html#kettle">kettle</a>
			
			
		&emsp;&emsp;
		Tags：
			
			<a href="/tags.html#kettle-ref">kettle</a>
			
			,
			
			
			<a href="/tags.html#cassandra-ref">cassandra</a>
			
			,
			
			
			<a href="/tags.html#pentaho-ref">pentaho</a>
			
			,
			
			
			<a href="/tags.html#hadoop-ref">hadoop</a>
			
			
		&emsp;&emsp;
		<a href='/kettle/2012/03/23/how-to-implement-cassandra-input-and-output-in-kettle4-2#comment' title='分享文章、查看评论' style="float:right;margin-right:.5em;">Comments</a>
	</div>
    </header>
    <div class="content"><p>这是在QQ群里有人问到的一个问题.<br />
如何在pdi-ce-4.2.X-stable上面实现cassandra的输入与输出,或是实现hadoop,hbase,mapreduce,mongondb的输入输出?</p>

<p>在kettle中实现cassandra的输入与输出有以下两种方式:<br />
第一种方式:自己编写cassandra输入输出组件<br />
第二种方式:使用别人编写好的插件,将其集成进来</p>

<p>当然还有第三种方法,直接使用4.3版本的pdi.<br />
第一种方法需要对cassandra很熟悉编写插件才可以做到,第二种方法可以通过拷贝pdi-ce-big-data-4.3.0-preview中的文件来完成.</p>

<p>在pdi-ce-big-data-4.3.0-preview<a href="http://ci.pentaho.com/job/pentaho-big-data-plugin/lastSuccessfulBuild/artifact/pentaho-big-data-plugin/dist/" target="_blank">(下载页面</a>)版本中可以看到kettle开始支持cassandra的输入和输出.<br />
故我们可以将4.3版本中的cassandra相关文件拷贝到4.2.1中.我使用的是pdi-ce-4.2.1-stable.<br />
在pdi-ce-big-data-4.3.0-preview/plugins目录下有以下目录或文件:
<pre>
.
|-- databases
|-- hour-partitioner.jar
|-- jobentries
|-- kettle-gpload-plugin
|-- kettle-hl7-plugin
|-- kettle-palo-plugin
|-- pentaho-big-data-plugin
|-- repositories
|-- spoon
|-- steps
`-- versioncheck
</pre></p>

<p>pentaho-big-data-plugin目录是kettle对大数据的集成与支持,我们只需要将该目录拷贝到pdi-ce-4.2.1-stable/plugins目录下即可.最后的结构如下
<pre>
.
|-- databases
|-- hour-partitioner.jar
|-- jobentries
|   <code>-- DummyJob
|       |-- DPL.png
|       |-- dummyjob.jar
|</code>-- plugin.xml
|-- pentaho-big-data-plugin
|   |-- lib
|   |   |-- apache-cassandra-1.0.0.jar
|   |   |-- apache-cassandra-thrift-1.0.0.jar
|   |   |-- aws-java-sdk-1.0.008.jar
|   |   |-- commons-cli-1.2.jar
|   |   |-- guava-r08.jar
|   |   |-- hbase-comparators-TRUNK-SNAPSHOT.jar
|   |   |-- jline-0.9.94.jar
|   |   |-- libthrift-0.6.jar
|   |   |-- mongo-java-driver-2.7.2.jar
|   |   |-- pig-0.8.1.jar
|   |   |-- xpp3_min-1.1.4c.jar
|   |   <code>-- xstream-1.3.1.jar
|</code>-- pentaho-big-data-plugin-TRUNK-SNAPSHOT.jar
|-- repositories
|-- spoon
|-- steps
|   |-- DummyPlugin
|   |   |-- DPL.png
|   |   |-- dummy.jar
|   |   <code>-- plugin.xml
|   |-- S3CsvInput
|   |   |-- jets3t-0.7.0.jar
|   |   |-- plugin.xml
|   |   |-- S3CIN.png
|   |</code>-- s3csvinput.jar
|   <code>-- ShapeFileReader3
|       |-- plugin.xml
|       |-- SFR.png
|</code>-- shapefilereader3.jar
<code>-- versioncheck
    |-- kettle-version-checker-0.2.0.jar
</code>-- lib
        `-- pentaho-versionchecker.jar</p>

<p>13 directories, 29 files
</pre></p>

<p>启动pdi-ce-4.2.1-stable之后,打开一个转换,在核心对象窗口就可以看到Big Data步骤目录了.
<div class="pic">
<a href="http://ww4.sinaimg.cn/mw600/48e24b4cjw1dr9zaa66nbj.jpg" target="_blank">
<img alt="" src="http://ww4.sinaimg.cn/mw600/48e24b4cjw1dr9zaa66nbj.jpg" title="pdi big data plugin in kette 4.2" class="aligncenter" width="600" height="375" />
</a>
</div></p>

<p><strong>获取pentaho-big-data-plugin源码</strong>
如果想在eclipse中查看或修改pentaho-big-data-plugin源码,该怎么做呢?<br />
你可以从<a href="http://ci.pentaho.com/job/pentaho-big-data-plugin/lastSuccessfulBuild/artifact/pentaho-big-data-plugin/dist/pentaho-big-data-plugin-TRUNK-SNAPSHOT-sources.zip" target="_blank">这里</a>下载到源码,然后将src下的文件拷贝到你的pdi-ce-4.2.1-stable源码工程中.</p>

<p>然后,需要在kettle-steps.xml中注册步骤节点<br />
例如,下面是MongoDbInput步骤的注册方法,请针对不同插件的不同类路径加以修改.
<pre>
<step id="MongoDbInput">
<description>i18n:org.pentaho.di.trans.step:BaseStep.TypeLongDesc.MongoDbInput
<classname>org.pentaho.di.trans.steps.mongodbinput.MongoDbInputMeta
<category>i18n:org.pentaho.di.trans.step:BaseStep.Category.Input
<tooltip>i18n:org.pentaho.di.trans.step:BaseStep.TypeTooltipDesc.MongoDbInput
<iconfile>ui/images/mongodb-input.png
</iconfile></tooltip></category></classname></description></step>
</pre></p>

<div class="note">
<h>注意:<br />
由于pdi-ce-4.2.1-stable中存在hive组件,故添加pentaho-big-data-plugin插件之后有可能会出现找不到类的情况,这是由于jar重复版本不一致导致的,按照异常信息,找到重复的jar并按情况删除一个jar包即可.
</h></div>

<p><strong>扩展阅读:</strong></p>

<ul>
<li>Pentaho Big Data Plugin <a href="http://wiki.pentaho.com/display/BAD/Getting+Started+for+Java+Developers" target="_blank">http://wiki.pentaho.com/display/BAD/Getting+Started+for+Java+Developers</a></li>
<li>pentaho-big-data-plugin ci
<a href="http://ci.pentaho.com/job/pentaho-big-data-plugin/lastSuccessfulBuild/artifact/pentaho-big-data-plugin/dist/" target="_blank">http://- - ci.pentaho.com/job/pentaho-big-data-plugin/lastSuccessfulBuild/artifact/pentaho-big-data-plugin/dist/</a></li>
<li>Pentaho Community Edition (CE) downloads <a href="http://wiki.pentaho.com/display/BAD/Downloads" target="_blank">http://wiki.pentaho.com/display/BAD/Downloads</a></li>
</ul>
</div>
    </article>
  </section>
  
  
  <section id="seam20120223the-process-of-seam-initiation">
    <article>
      <header>
      <h3><a href="/seam/2012/02/23/the-process-of-seam-initiation">Seam的启动过程</a></h3>
      <div class="c9">
     		Author: JavaChen
     		&emsp;&emsp;
		Categories：
			
			<a href="/categories.html#seam">seam</a>
			
			
		&emsp;&emsp;
		Tags：
			
			<a href="/tags.html#seam-ref">seam</a>
			
			
		&emsp;&emsp;
		<a href='/seam/2012/02/23/the-process-of-seam-initiation#comment' title='分享文章、查看评论' style="float:right;margin-right:.5em;">Comments</a>
	</div>
    </header>
    <div class="content"><p>了解seam2的人知道，seam是通过在web.xml中配置监听器启动的。注意，本文中的seam是指的seam2，不是seam3.
<pre lang="xml">
&lt; listener&gt;
    &lt; listener-class&gt;org.jboss.seam.servlet.SeamListener&lt; /listener-class&gt;
&lt; /listener&gt;
</pre></p>

<p>该监听器会做哪些事情呢？看看Gavin King对SeamListener类的描述。
<blockquote>Drives certain Seam functionality such as initialization and cleanup of application and session contexts from the web application lifecycle.</blockquote></p>

<p>从描述中可以知道
SeamListener主要完成应用以及web应用生命周期中的session上下文的初始化和清理工作。</p>

<p>该类实现了ServletContextListener接口，在contextInitialized(ServletContextEvent event)方法内主要初始化生命周期并完成应用的初始化，在contextDestroyed(ServletContextEvent event)方法内结束应用的生命周期。
该类实现了HttpSessionListener接口，主要是用于在生命周期中开始和结束session。
<strong>第一步</strong>，构造方法里从ServletContext获取一些路径信息：warRoot、warClassesDirectory、warLibDirectory、hotDeployDirectory。</p>

<p><strong>第二步</strong>，扫描配置文件完成seam组件的初始化（Initialization的create方法）。
其中包括：添加命名空间、初始化组件、初始化Properties、初始化jndi信息。这一步，其实主要是读取一些配置文件,加载seam组件。</p>

<ul>
<li>1.添加命名空间</li>
<li>2.从“/WEB-INF/components.xml”加载组件</li>
<li>3.从“/WEB-INF/events.xml”加载组件</li>
<li>4.从“META-INF/components.xml”加载组件</li>
<li>5.从ServletContext初始化Properties</li>
<li>6.从“/seam.properties”初始化Properties</li>
<li>7.初始化jndi Properties</li>
<li>8.从system加载Properties</li>
</ul>

<p><strong>第三步</strong>，seam初始化过程（Initialization的init方法）。</p>

<ul>
<li>1.ServletLifecycle开始初始化</li>
<li>2.设置Application上下文</li>
<li>3.添加Init组件</li>
<li>4.通过standardDeploymentStrategy的注解和xml组件扫描组件</li>
<li>5.判断jbpm是否安装</li>
<li>6.检查默认拦截器</li>
<li>7.添加特别组件</li>
<li>8.添加war root部署、热部署</li>
<li>9.安装组件</li>
<li>10.导入命名空间</li>
<li>11.ServletLifecycle结束初始化。启动生命周期为APPLICATION的组件。</li>
</ul>

<p>如果组件标注为startup，则会构造其实例进行初始化。例如seam于Hibernate的集成，就可以通过此方法初始化Hibernate，对应的组件类为org.jboss.seam.persistence.HibernateSessionFactory。</p>
</div>
    </article>
  </section>
  
  <div class="pagination">
      <ul>
        <li class="next"><a href='/page3'>&larr; Previous</a></li>
        <li><a href="/archive.html">Archive</a></li>
        <li class="prev"><a href='/page5'>Next &rarr;</a></li>
      </ul>
  </div>
  </div>

  <aside class="span4">
    <section>
   	 <h4>TODO</h4>
   	 <ul style="margin-top: -3px">
		<li>hadoop权威指南</li>
       </ul>
    </section>

    <section>
    <h4>Recent Posts</h4>
    <ul id="recent_posts">
      <li class="post">
        <a href="/hadoop/2013/08/02/hadoop-install-script">hadoop自动化安装shell脚本</a>
      </li>
      <li class="post">
        <a href="/hadoop/2013/08/01/remote-debug-hadoop">远程调试hadoop各组件</a>
      </li>
      <li class="post">
        <a href="/hadoop/2013/07/20/install-rhadoop">安装RHadoop</a>
      </li>
      <li class="post">
        <a href="/hadoop/2013/06/24/install-cdh-by-cloudera-manager">通过Cloudera Manager安装CDH</a>
      </li>
      <li class="post">
        <a href="/hadoop/2013/04/17/access-idh-2.3-hbase-in-kettle">kettle访问IDH2.3中的HBase</a>
      </li>
      <li class="post">
        <a href="/kettle/2013/04/07/add-a-field-from-paramter-to-output">kettle中添加一个参数字段到输出</a>
      </li>
      <li class="post">
        <a href="/hadoop/2013/04/06/install-cloudera-cdh-by-yum">从yum安装Cloudera CDH集群</a>
      </li>
      <li class="post">
        <a href="/hadoop/2013/03/29/install-impala">安装impala过程</a>
      </li>
      <li class="post">
        <a href="/hadoop/2013/03/24/manual-install-Cloudera-Hadoop-CDH">手动安装Cloudera Hadoop CDH</a>
      </li>
      <li class="post">
        <a href="/hadoop/2013/03/24/manual-install-Cloudera-hbase-CDH">手动安装Cloudera HBase CDH</a>
      </li>
    </ul>
    </section>
    
    <script type="text/javascript">
	var duoshuoQuery = {short_name:"javachen"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	
	<section>
		<h3>Recent Comments</h3>
		<ul class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></ul>
	<script>if (typeof DUOSHUO !== 'undefined')	DUOSHUO.RecentComments('.ds-recent-visitors');</script>
	</section>
	
	<section>
		<h3>Recent Vistors</h3>
		 <ul class="ds-recent-visitors" data-num-items="16"></ul>
		<script>if (typeof DUOSHUO !== 'undefined')	DUOSHUO.RecentVisitors('.ds-recent-visitors');</script>
	</section>
	 
     <section>
   	 <h4>WeiBo</h4>
   	 <iframe id="sina_widget_1222789964" style="width:100%; height:500px;" frameborder="0" scrolling="no" src="http://v.t.sina.com.cn/widget/widget_blog.php?uid=1222789964&height=500&skin=wd_01&showpic=0"></iframe>
    </section>
    
    <section>
	  
	    <h4>Categories</h4>
	    <ul class="tag_box">
	      
	      


  
     
    	<li><a href="/categories.html#cloud-ref">
    		cloud <span>9</span>
    	</a></li>
     
    	<li><a href="/categories.html#javascript-ref">
    		javascript <span>4</span>
    	</a></li>
     
    	<li><a href="/categories.html#pentaho-ref">
    		pentaho <span>2</span>
    	</a></li>
     
    	<li><a href="/categories.html#extjs-ref">
    		extjs <span>2</span>
    	</a></li>
     
    	<li><a href="/categories.html#xml-ref">
    		xml <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#mondrian-ref">
    		mondrian <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#kettle-ref">
    		kettle <span>8</span>
    	</a></li>
     
    	<li><a href="/categories.html#jsf-ref">
    		jsf <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#seam-ref">
    		seam <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#java-ref">
    		java <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#cassandra-ref">
    		cassandra <span>2</span>
    	</a></li>
     
    	<li><a href="/categories.html#github-ref">
    		github <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#work-ref">
    		work <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#hadoop-ref">
    		hadoop <span>11</span>
    	</a></li>
    
  


	    </ul>
	  
     </section>
       <section>
    <h4>Links</h4>
   	<ul>
	<li>Java开发
			<ul>
				<li><a href="http://blog.frankel.ch/" target="_blank">A Java geek</a></li>
				<li><a href="http://xinwang.osdn.cn/" target="_blank">辛望的开发日志</a></li>
				<li><a href="http://kohsuke.org/" target="_blank">Kohsuke Kawaguchi</a></li>
				<li><a href="http://www.longtask.com/blog/" target="_blank">龙浩的blog</a>就职于阿里巴巴云计算</li>
				<li><a href="http://jdkcn.com/" target="_blank">莫多泡泡</a>A Java programmeri</li>
				<li><a href="http://hackfisher.info/" target="_blank">HackFisher</a></li>
				<li><a href="http://bluedash.net/categories/%E7%BC%96%E7%A8%8B/spaces" target="_blank">蓝点</a></li>
				<li><a href="http://javafans.info/" target="_blank">Java爱好者</a></li>
				<li><a href="http://www.yankay.com/" target="_blank">我自然</a>颜开的博客</li>
			</ul>
		</li>
		<li>前端开发
			<ul>
				<li><a href="http://panweizeng.com/" target="_blank">潘魏增</a>美团网前端工程师</li>
				<li><a href="http://14px.com/" target="_blank">十四像素</a></li>
			</ul>
		</li>
		<li>其他
			<ul>
				<li><a href="http://blog.boluotou.com/" target="_blank">圆木菠萝罐</a>一个大学学长</li>
				<li><a href="http://blog.codingnow.com/" target="_blank">云风的BLOG</a></li>
				<li><a href="http://www.yy42.net/blog/" target="_blank">程显峰</a></li>
				<li><a href="http://coolshell.cn/" target="_blank">酷壳–CoolShell.cn</a></li>
				<li><a href="http://www.coder4.com/" target="_blank">四号程序员</a></li>
				<li><a href="http://timyang.net/" target="_blank">Tim[后端技术]</a></li>

				<li><a href="http://www.agiledon.com/" target="_blank">捷道</a>Thoughtworks架构师</li>
				<li><a href="http://log4d.com/" target="_blank">Log4D</a></li>

				<li><a href="http://dev.ymeng.net/" target="_blank">Dev Notes</a></li>
				<li><a href="http://www.dbanotes.net/" target="_blank">DBA Notes</a></li>		
			</ul>
		</li>
	</ul>
  </section>
  </aside>
</div>

  </div>
</div>


      </div>

      <footer>
        <p>&copy; JavaChen 2013 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a> | <script language="javascript" type="text/javascript" src="http://js.users.51.la/12111481.js"></script>
<noscript><a href="http://www.51.la/?12111481" target="_blank"><img alt="Statistic" src="http://img.users.51.la/12111481.asp" style="border:none" /></a></noscript>
        </p>
      </footer>

    </div> <!-- /container -->
    
  </body>
</html>


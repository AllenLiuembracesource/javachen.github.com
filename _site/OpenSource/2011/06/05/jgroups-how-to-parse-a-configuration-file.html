<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <link rel="alternate" type="application/rss+xml" title="RSS 2.0 - all posts" href="http://blog.javachen.com/atom.xml" />
    <link REL="SHORTCUT ICON" HREF="http://blog.javachen.com/images/favicon.ico"/>
    <!-- weibo -->
    <meta property="wb:webmaster" content="61eb31a6e636506d" />
    <meta name="ujianVerification" content="f8b60286538bf86567069598d8a5d6cc" />
    <!-- seo -->
    <meta name="description" content="javachen" />
    <meta name="keywords" content="html,xhtml,css,js,javascript,ajax,jQuery,java,struts,struts2,hibernate,spring,jpa,maven,ant,git,github,jekyll,markdown,wiki,
    java,jboss,bi,pentaho,kettle,nosql,cassandra,bigdata,cloud,opensource" />

    <title>JGroups 如何读取配置文件</title>
    <link rel="stylesheet" href="/stylesheets/master.css" type="text/css" media="screen" charset="utf-8"/>
    <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" media="screen" charset="utf-8"/>
    <link type="text/css" rel="stylesheet" href="/javascripts/syntaxhighlighter/styles/shCoreMidnight.css"/>
    <link type="text/css" rel="stylesheet" href="/javascripts/syntaxhighlighter/styles/shThemeMidnight.css"/>
    <script src="/javascripts/jquery.js" type="text/javascript" charset="utf-8"></script>
    <script src="/javascripts/jquery.github.js" type="text/javascript" charset="utf-8"></script>
  </head>
  <body>
  <a href="http://github.com/javachen/javachen.github.com"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>
    <div id='wrapper'>
      <div id='header'>
        <h1><a href='/'>JavaChen</a></h1>
        
        <div id='menu'>
          <ul>
            <li><a href='/' id='home-link' title='Home'>Home</a></li>
            <li><a href='/blog.html' id='blog-link' title='Blog'>Blog</a></li>
            <li><a href='/categories.html' id='categories-link' title='Categories'>Categories</a></li>
            <li><a href='/tags.html' id='tags-link' title='Tags'>Tags</a></li>
            <li><a href='/about.html' id='about-link' title='About'>About</a></li>
            <li><a href='http://github.com/javachen' target='_blank' title='GitHub' rel='me' id='github-link'>GitHub</a></li>
            <li><a href='http://weibo.com/chenzhijun' title='weibo' target='_blank' id='weibo-link'>Weibo</a></li>
          </ul>
        </div>
      </div>
      <div id='content'>
        <div class='post'>
  <span class='date'>05 Jun 2011</span>
  <a href='#comments' title='分享文章、查看评论' style="float:right">Comments</a>
  <h1><a href='/OpenSource/2011/06/05/jgroups-how-to-parse-a-configuration-file.html'>JGroups 如何读取配置文件</a></h1>
  <div class='body'><p><a title="A Toolkit for Reliable Multicast Communication" href="http://www.jgroups.org/" target="_blank">JGroups</a>是一个可靠的组播通讯工具集（需要说明的是，这并不是说必须要使用IP Multicast,JGroups也可以使用TCP来实现）。JGroups可以用来创建一个组，这个组中的成员可以给其他成员发送消息。</p>

<p>JGroups的主要功能如下：
<div class="note">创建和删除组，组成员可以分布在局域网或广域网中<br />
组成员加入和离开组<br />
成员关系的自动侦测并通知成员的加入，离开和丢失<br />
侦测并删除丢失的成员<br />
发送和接收成员到组的消息（点到多点）<br />
发送和接收成员到成员的消息（点到点）</div>
关于<a title="A Toolkit for Reliable Multicast Communication" href="http://www.jgroups.org/" target="_blank">JGroups</a>更详细的介绍，请参考<a title="Permanent Link to JGroups 介绍及配置说明" href="../2011/06/jgroups-introduction-and-configruation/">JGroups 介绍及配置说明</a>。
<!--more-->
JGroups的配置文件有两种，一种是XML文件，一种是纯文本。<br />
Xml文件格式如下：
<pre lang="xml"><config>
     <udp mcast_port="${jgroups.udp.mcast_port:45588}"
         tos="8"
         ucast_recv_buf_size="20M"
         ucast_send_buf_size="640K"
         mcast_recv_buf_size="25M"
         mcast_send_buf_size="640K"
         loopback="true"
         discard_incompatible_packets="true"
         max_bundle_size="64K"
         max_bundle_timeout="30"
         ip_ttl="${jgroups.udp.ip_ttl:2}"
         enable_bundling="true"
         enable_diagnostics="true"
         thread_naming_pattern="cl"
         timer.num_threads="4"</config></pre></p>

<p>         thread_pool.enabled="true"<br />
         thread_pool.min_threads="2"<br />
         thread_pool.max_threads="8"<br />
         thread_pool.keep_alive_time="5000"<br />
         thread_pool.queue_enabled="true"<br />
         thread_pool.queue_max_size="10000"<br />
         thread_pool.rejection_policy="discard"</p>

<p>         oob_thread_pool.enabled="true"<br />
         oob_thread_pool.min_threads="1"<br />
         oob_thread_pool.max_threads="8"<br />
         oob_thread_pool.keep_alive_time="5000"<br />
         oob_thread_pool.queue_enabled="false"<br />
         oob_thread_pool.queue_max_size="100"<br />
         oob_thread_pool.rejection_policy="Run"/></p>

<p>    <ping timeout="2000"<br />
            num_initial_members="3"/>
    <merge2 max_interval="30000"<br />
            min_interval="10000"/>
    <fd_sock />
    <fd_all />
    <verify_suspect timeout="1500" />
    <barrier />
    <pbcast .NAKACK use_stats_for_retransmission="false"<br />
                   exponential_backoff="0"<br />
                   use_mcast_xmit="true" gc_lag="0"<br />
                   retransmit_timeout="300,600,1200"<br />
                   discard_delivered_msgs="true"/>
    <unicast timeout="300,600,1200" />
    <pbcast .STABLE stability_delay="1000" desired_avg_gossip="50000"<br />
                   max_bytes="1M"/>
    <pbcast .GMS print_local_addr="false" join_timeout="3000"</p>

<p>                view_bundling="true"/>
    <fc max_credits="500K"<br />
                    min_threshold="0.20"/>
    <frag2 frag_size="60K" />
    <pbcast .streaming_state_transfer />
    <!--pbcast.STATE_TRANSFER  /-->
    <!-- pbcast.FLUSH  /-->

关于上面配置文件的含义，涉及到JGroups的协议栈，你可以参考这篇文章：<a href="http://www.4ucode.com/Study/Topic/1139525">JGroups的协议栈</a>。</p>

<p><tt><strong>JChannel</strong></tt><strong> </strong>
如果你想创建一个<tt>JChannel</tt>，你可以使用下面的构造方法：
<pre lang="java">public JChannel(String props) throws ChannelException {}</pre>
该构造方法创建了一个<tt>JChannel</tt><tt>的实例。这个</tt>props参数指向一个xml配置文件，即上面的协议栈xml文件。当前构造方法的参数是个字符串，当然<tt>JChannel</tt><tt>还提供了传入DOM 节点或是URL或是File或是ProtocolStackConfigurator或是JChannel的构造方法。</tt>
<pre lang="java">public JChannel(&lt;strong&gt;boolean create_protocol_stack&lt;/strong&gt;) {}
public JChannel() throws ChannelException {}
public JChannel(File properties) throws ChannelException {}
public JChannel(Element properties) throws ChannelException {}
public JChannel(URL properties) throws ChannelException {}
public JChannel(String  properties) throws ChannelException {}
public JChannel(Object  properties) throws ChannelException {}
public JChannel(ProtocolStackConfigurator configurator) throws ChannelException {}
public JChannel(JChannel ch) throws ChannelException {}</pre>
<tt>如果传入的参数为空，则默认的</tt>properties将会被使用。如果一个channel不能在构造方法里被创建，则会抛出一个ChannelException异常。<tt></tt></p>

<p>这里主要看看一下两个构造方法：<br />
第一个构造方法：
<pre lang="java">public JChannel(boolean create_protocol_stack) {
        if(create_protocol_stack) {
            try {
             init(ConfiguratorFactory.getStackConfigurator(DEFAULT_PROTOCOL_STACK));
            }
            catch(ChannelException e) {
                throw new RuntimeException(e);
            }
        }
}</pre>
上面构造方法传入一个boolean类型的参数create_protocol_stack，如果该参数为true，则根据默认的配置文件（<em>DEFAULT_PROTOCOL_STACK=</em> "udp.xml"）通过调用init()方法初始化配置信息。<br />
第二个构造方法：
<pre lang="java">public JChannel(String properties) throws ChannelException {
        this(ConfiguratorFactory.getStackConfigurator(properties));
}</pre>
第二个构造方法传入一个字符串（xml文件名），然后内部调用JChannel(ProtocolStackConfigurator configurator)构造方法，实现初始化配置信息。从这里可以想到，其他的构造方法内部应该都是根据参数获得一个ProtocolStackConfigurator实例，然后调用this(protocolStackConfigurator)方法。<br />
第一个构造方法中调用了init方法：
<pre lang="java">protected final void init(ProtocolStackConfigurator configurator) throws ChannelException {
        if(log.isInfoEnabled())
            log.info("JGroups version: " + Version.description);</pre></p>

<p>        List&lt;ProtocolConfiguration&gt; configs;<br />
        try {<br />
            configs=configurator.getProtocolStack();<br />
            for(ProtocolConfiguration config: configs)<br />
                config.substituteVariables();  // replace vars with system props<br />
        }<br />
        catch(Exception e) {<br />
            throw new ChannelException("unable to parse the protocol configuration", e);<br />
        }</p>

<p>        synchronized(Channel.class) {<br />
            prot_stack=new ProtocolStack(this);<br />
            try {<br />
                prot_stack.setup(configs);<br />
                // Setup protocol stack (creates protocol, calls init() on them)<br />
            }<br />
            catch(Throwable e) {<br />
                throw new ChannelException("unable to setup the protocol stack", e);<br />
            }<br />
        }<br />
    }
该方法内部主要先通过configurator获得协议栈并设置各个协议的变量值，然后通过JChannel构造一个ProtocolStack对象并设置协议栈内容。</p>

<p><strong>ConfiguratorFactory</strong><strong> </strong>
在上面的构造方法中有这样一行代码：
<pre lang="java">ConfiguratorFactory.&lt;em&gt;getStackConfigurator&lt;/em&gt;(properties)</pre>
JChannel类通过调用配置文件工程类（ConfiguratorFactory）的静态方法来获得一个ProtocolStackConfigurator实例。<br />
ConfigurationFactory是一个返回协议栈配置类（ProtocolStackConfigurator）的工厂类。协议栈配置类读取配置文件并且解析该配置以便ProtocolStack能够创建一个栈（Stack）。</p>

<p>目前，该工厂能够返回以下两种对象：
<pre lang="java">	1.XmlConfigurator ：解析xml文件。
	2.PlainConfigurator ：使用旧格式的字符串：UDP:FRAG</pre>
ConfigurationFactory类结构如下：</p>

<p>其中主要看看<strong>public</strong> <strong>static</strong> ProtocolStackConfigurator getStackConfigurator(String properties) <strong>throws</strong> ChannelException {}方法：
<pre lang="java">
public static ProtocolStackConfigurator getStackConfigurator(
		String properties) throws ChannelException {
		// added by bela: for null String props we use the default properties
		if (properties == null)
			properties = JChannel.DEFAULT_PROTOCOL_STACK;</pre></p>

<p>		// Attempt to treat the properties string as a pointer to an XML<br />
		// configuration.<br />
		XmlConfigurator configurator = null;</p>

<p>		try {<br />
			checkForNullConfiguration(properties);<br />
			configurator = getXmlConfigurator(properties);<br />
		} catch (IOException ioe) {<br />
			throw createChannelConfigurationException(ioe);<br />
		}</p>

<p>		// Did the properties string point to a JGroups XML configuration?<br />
		if (configurator != null) {<br />
			return configurator;<br />
		} else {<br />
			// Attempt to process the properties string as the old style<br />
			// property string.<br />
			return new PlainConfigurator(properties);<br />
		}<br />
	}
该方法先用XmlConfigurator解析传入参数properties，如果解析失败（properties不为xml文件名，而是字符串）则用PlainConfigurator解析配置文件。该方法最终返回ProtocolStackConfigurator的一个实例对象，以供JChannel类内部的init方法调用。</p>

<p>获得XmlConfigurator的方法如下：
<pre lang="java">static XmlConfigurator getXmlConfigurator(String properties)
		throws IOException {
		XmlConfigurator returnValue = null;
		InputStream configStream = getConfigStream(properties);</pre></p>

<p>		if (configStream != null) {<br />
			checkJAXPAvailability();<br />
			returnValue = XmlConfigurator.getInstance(configStream);<br />
		}</p>

<p>		return returnValue;<br />
	}
<strong>XmlConfigurator</strong></p>

<p>使用XML配置一个协议栈。一个XML配置文件里会配置多个协议配置类，故XmlConfigurator类内部应该有一个集合存放这多个协议配置类，也即是List<protocolconfiguration>集合类。</protocolconfiguration></p>

<p>该类使用SAX解析XMl，并在解析前可以根据schema验证XML文件合法性。待验证通过之后，获得XML文件的根节点（config节点），然后调用<em>parse</em>(configElement)方法，返回其执行结果（XmlConfigurator的一个实例）。</p>

<p><em>parse</em>(configElement)方法如下：
<pre lang="java">
protected static XmlConfigurator parse(Element root_element)
		throws java.io.IOException {
	XmlConfigurator configurator = null;
	final LinkedList<protocolconfiguration>prot_data = 
                new LinkedLis</protocolconfiguration><protocolconfiguration>();</protocolconfiguration></pre></p>

<p>	try {<br />
		String root_name = root_element.getNodeName();<br />
		if (!"config".equals(root_name.trim().toLowerCase())) {<br />
			throw new IOException("invalid XML configuration");<br />
		}</p>

<p>		NodeList prots = root_element.getChildNodes();<br />
		for (int i = 0; i < prots.getLength(); i++) {<br />
			Node node = prots.item(i);<br />
			if (node.getNodeType() != Node.ELEMENT_NODE)<br />
				continue;</p>

<p>			Element tag = (Element) node;<br />
			String protocol = tag.getTagName();<br />
			Map<String, String> params = new HashMap<string , String>();</p>

<p>			NamedNodeMap attrs = tag.getAttributes();<br />
			int attrLength = attrs.getLength();<br />
			for (int a = 0; a &lt; attrLength; a++) {<br />
				Attr attr = (Attr) attrs.item(a);<br />
				String name = attr.getName();<br />
				String value = attr.getValue();<br />
				params.put(name, value);<br />
			}<br />
			ProtocolConfiguration cfg = new ProtocolConfiguration(protocol,<br />
				params);<br />
			prot_data.add(cfg);<br />
			}<br />
		configurator = new XmlConfigurator(prot_data);<br />
	} catch (Exception x) {<br />
		if (x instanceof java.io.IOException)<br />
			throw (java.io.IOException) x;<br />
		else {<br />
			IOException tmp = new IOException();<br />
			tmp.initCause(x);<br />
			throw tmp;<br />
		}<br />
	}<br />
	return configurator;<br />
}
该方法主要是解析config节点下的子节点，将各个节点的属性以键值对的方式存入map，然后将该通过ProtocolConfiguration cfg = <strong>new</strong> ProtocolConfiguration(protocol,params)获得一个ProtocolConfiguration实例，然后调用prot_data.add(cfg)将该协议配置存入集合，最后通过<strong>new</strong> XmlConfigurator(prot_data)返回一个新的XmlConfigurator实例。</p>

<p><strong>ProtocolConfiguration</strong>
解析参数并封装一个协议。<br />
在XmlConfigurator中被使用，通过读取配置文件中的协议参数来实例化一个ProtocolConfiguration对象（ProtocolConfiguration cfg = <strong>new</strong> ProtocolConfiguration(protocol,params)）</p>

<p><strong>ProtocolStack</strong>
协议栈。构造方法传入JChannel对象，并通过<strong>public</strong> <strong>void</strong> setup(List<protocolconfiguration>configs) <strong>throws</strong> Exception {}方法设置协议集合。
<strong>
接下来就涉及到协议栈的配置及初始化了，这部分本文不做分析。</strong></protocolconfiguration></p>

<p><tt><strong>其他几个类</strong></tt><strong> </strong>
上面的几个类（除了）都在org.jgroups.conf包内，其实该包内还有几个类：
<div class="trace">ClassConfigurator ：类配置，在org.jgroups.stack包中被用到<br />
PropertyConverter ：属性转换器<br />
PropertyConverters ：属性转换器的封装类<br />
PropertyHelper ：属性帮助类，在org.jgroups.stack包中被用到</div>
<strong><span style="color: red;">附：</span></strong>
除了上面两种配置文件，JGroups还可以支持在代码中初始化协议栈配置，代码如下：
<pre lang="java">JChannel ch = new JChannel(false); // 1
ProtocolStack stack = new ProtocolStack(); // 2
ch.setProtocolStack(stack); // 3
stack.addProtocol(new UDP().setValue("bind_addr", 
         InetAddress.getByName("192.168.1.5")))
       .addProtocol(new PING())
       .addProtocol(new MERGE2()).addProtocol(new FD_SOCK())
       .addProtocol(new FD_ALL().setValue("timeout", 12000).setValue("interval", 3000))
       .addProtocol(new   VERIFY_SUSPECT())
       .addProtocol(new BARRIER())
       .addProtocol(new NAKACK())
       .addProtocol(new UNICAST2())
       .addProtocol(new STABLE())
       .addProtocol(new GMS())
       .addProtocol(new UFC())
       .addProtocol(new MFC())
       .addProtocol(new FRAG2()); // 4
stack.init(); // 5</pre></p>
</div>
  <div class="original-post corner-all"><strong>原创文章，转载请注明：</strong>转载自：<a href='/OpenSource/2011/06/05/jgroups-how-to-parse-a-configuration-file.html'>JGroups 如何读取配置文件</a></div>
</div>

<!-- JiaThis Button BEGIN -->
<div id="jiathis_style_32x32">
<a class="jiathis_button_tsina"></a>
<a class="jiathis_button_tqq"></a>
<a class="jiathis_button_douban"></a>
<a class="jiathis_button_googleplus"></a>
<a class="jiathis_button_evernote"></a>
<a class="jiathis_button_ujian"></a>
<a class="jiathis_button_fav"></a>
<a class="jiathis_button_copy"></a>
<a class="jiathis_button_ishare"></a>
<a href="http://www.jiathis.com/share?uid=1352701524431612" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
	data_track_clickback:true,
	summary:"",
	ralateuid:{
		"tsina":"chenzhijun"
	},
	hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1352701524431612" charset="utf-8"></script>

<!-- JiaThis Button END -->

<!-- Wumii Related BEGIN -->
<div id="comments"  style="padding-bottom: 1em;"/>
<script type="text/javascript" id="wumiiRelatedItems"></script>
<script type="text/javascript">
    var wumiiPermaLink = ""; //请用代码生成文章永久的链接
    var wumiiTitle = ""; //请用代码生成文章标题
    var wumiiTags = ""; //请用代码生成文章标签，以英文逗号分隔，如："标签1,标签2"
    var wumiiSitePrefix = "http://blog.javachen.com/";
    var wumiiParams = "&num=9&mode=1&pf=JAVASCRIPT";
</script>
<script type="text/javascript" src="http://widget.wumii.com/ext/relatedItemsWidget"></script>
<a href="http://www.wumii.com/widget/relatedItems" style="border:0;">
    <img src="http://static.wumii.cn/images/pixel.png" alt="无觅相关文章插件，快速提升流量" style="border:0;padding:0;margin:0;" />
</a>
<!-- Wumii Related END -->

        <div class='clearfix'></div>
      </div>
      <!-- Duoshuo Comment BEGIN -->
      <div class="ds-thread"></div>
      <script type="text/javascript">
      var duoshuoQuery = {short_name: "huaiyu2008"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
      <!-- Duoshuo Comment END -->
    </div>
    <div id='footer'>
      Copyright &copy; 2012 JavaChen. Hosted by <a href='http://github.com/javachen/javachen.github.com/' target='_blank'>GitHub</a> and powered by <a href='http://github.com/mojombo/jekyll'>Jekyll</a>. Templates from <a href='http://github.com/mbleigh/mbleigh.github.com/' target='_blank'>Michael Bleigh</a>. <script language="javascript" type="text/javascript" src="http://js.users.51.la/2845297.js"></script>
<noscript><a href="http://www.51.la/?2845297" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/2845297.asp" style="border:none" /></a></noscript>
    </div>

    <!-- 语法高亮 BEGIN -->
    <script src="/javascripts/syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="/javascripts/syntaxhighlighter/scripts/shAutoloader.js" type="text/javascript"></script>
    <script type="text/javascript">
    $(function() {
      SyntaxHighlighter.autoloader.apply(null, path(
        'applescript            @shBrushAppleScript.js',
        'actionscript3 as3      @shBrushAS3.js',
        'bash shell             @shBrushBash.js',
        'coldfusion cf          @shBrushColdFusion.js',
        'cpp c                  @shBrushCpp.js',
        'c# c-sharp csharp      @shBrushCSharp.js',
        'css                    @shBrushCss.js',
        'delphi pascal          @shBrushDelphi.js',
        'diff patch pas         @shBrushDiff.js',
        'erl erlang             @shBrushErlang.js',
        'groovy                 @shBrushGroovy.js',
        'java                   @shBrushJava.js',
        'jfx javafx             @shBrushJavaFX.js',
        'js jscript javascript  @shBrushJScript.js',
        'perl pl                @shBrushPerl.js',
        'php                    @shBrushPhp.js',
        'text plain             @shBrushPlain.js',
        'py python              @shBrushPython.js',
        'ruby rails ror rb      @shBrushRuby.js',
        'sass scss              @shBrushSass.js',
        'scala                  @shBrushScala.js',
        'sql                    @shBrushSql.js',
        'vb vbnet               @shBrushVb.js',
        'xml xhtml xslt html    @shBrushXml.js'
      ));
      SyntaxHighlighter.config.bloggerMode = true;
      SyntaxHighlighter.all();
    });
    function path() {
      var args = arguments, result = [];
           
      for(var i = 0; i < args.length; i++) {
        result.push(args[i].replace('@', '/javascripts/syntaxhighlighter/scripts/'));
      }
      return result;
    };
    </script>
    <!-- 语法高亮 END -->

   <!-- UJian Button BEGIN -->
   <script type="text/javascript" src="http://v1.ujian.cc/code/ujian.js?type=slide&btn=4&fade=1&uid=1709061"></script>
   <!-- UJian Button END -->
  </body>
</html>
